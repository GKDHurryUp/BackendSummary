
### 二叉树寻路 ###
在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。
在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；
在偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。

1. 把顺序排列的二叉树写出来，可以发现label/2的结果按照**之行排列**的计算结果是**顺序排列**的**对称点**
	如果能用**n(所在的行数)求得这两个对称的和**，就可以解得此题了
	X=(Left+Right)−Label/2=3∗(2^n−1)−1−Label/2

2. 位运算
	先右移一位（就是/2）
	除第一位之外，按位取反

### ×圆圈中最后剩下的数字

0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字

1. 暴力模拟循环链表（超时）

2. 数学+递归（约瑟夫环）

   建模为函数 `f(n, m)`，该函数的返回值为最终留下的元素的序号

   长度为 `n` 的序列会先删除第 `m % n` 个元素，然后剩下一个长度为 `n - 1` 的序列

   设`f(n, m)=y`，`f(n-1, m)=x`，寻求他们之间的关系

   - 有n个数时，划掉的数下标为`(m-1) % n`，==再往后数x+1个数就找到答案了==，化简过后

     `f(n,m)=(m + x)% n `

### ×==阶乘尾数==

设计一个算法，算出 n 阶乘有多少个尾随零。

1. 规律

   要想得到0，==**乘数必可分解为2*5**，因为 **2 的个数必定比 5 的个数多**==，因此只需求 5 的个数

   注意：25是两个5，125是三个5

    count = n / 5 + n / 25 + n / 125 + ...
    最终分母可能过大溢出，上面的式子可以进行转换

   count = n / 5 + n / 5 / 5 + n / 5 / 5 / 5 + ...

### 数字序列中某一位的数字

数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。

请写一个函数，求任意第n位对应的数字。

1. 规律

   可以根据n所在多少位，先求出n所在的数字；
   再将该数字转化为字符串；
   最后求出n在字符串的第几位并将该位输出即可。

   **要把0排除，0不参与这种规律**

### ×1～n整数中1出现的次数

输入一个整数 `n` ，求1～n这n个整数的十进制表示中1出现的次数。

==思路：将 1~ n 的个位、十位、百位、...的 1 出现次数相加，即为 1 出现的总次数。==

使用curr表示当前位数，高位的数字为high，低位为low， digit为10^i表示curr在第几位

- curr为0，出现1的次数即为`high * digit`
- curr为1，出现1的次数为`high * digit + low + 1`
- curr为2~9，出现1的次数为`(high + 1)*digit`

初始化：digit = 1, low = 0, curr = n % 10, high = n / 10

### ×0～n整数中2出现的次数

输入一个整数 `n` ，求0～n这n个整数的十进制表示中2出现的次数。

==思路：将 1~ n 的个位、十位、百位、...的 2 出现次数相加，即为 2 出现的总次数。==

- curr为0~1，出现1的次数即为`high * digit`
- curr为2，出现1的次数为`high * digit + low + 1`
- curr为3~9，出现1的次数为`(high + 1)*digit`

（求2出现的次数也是一样）

### 1比特与2比特字符

有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。

现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。

1. 线性遍历

   扫描到1，则i+=2，扫描到0，则i++，看i是否落在 bits.length−1

2. 贪心

   从后往前看，==最后一位是否为一比特字符，只和他左侧出现的连续的 1 的个数有关==

