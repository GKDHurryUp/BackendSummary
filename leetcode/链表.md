## 链表结构

```java
class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}
```

### 取得链表长度

方法一：经过之后curr为null
	int len = 0;
	while(curr != null){
		len++;
		curr = curr.next;
	}
方法二：经过之后curr为链表尾部，不为null
	int len = 1;
	while(curr.next != null){
		len++;
		curr = curr.next;
	}

### 从尾到头打印链表

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）

1. 使用栈
2. ==先取得链表长度，从后到前添加元素==

### 两数相加

链表各自的位数是按照逆序的方式存储的
	注意：	当一个列表比另一个列表长时
		当一个列表为空时，即出现空列表
		求和运算最后可能出现额外的进位

### 两数相加Ⅱ

链表各自的位数是按照顺序的方式存储的
方法一：
	建立三个栈，利用后进先出，将链表逆序过来
方法二：
	二个栈，头插法

### 链表的中间结点

给定一个带有头结点 `head` 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

1. 建立数组，将链表元素加入到数组中，返回数组长度/2索引的链表元素

2. 单指针

   遍历两次。

3. 快慢指针。

   快的指针每次走两个，快的到达尾部时，慢的刚好到中间
   	fast = head.next; 奇数个节点找到中点，偶数个节点找到中心左边的节点
   	fast = head; 奇数个节点找到中点，偶数个节点找到中心右边的节点

### 二进制链表转整数

链表中每个结点的值不是 0 就是 1，返回该链表所表示数字的 **十进制值** 

方法一：
	遍历链表转为字符串，使用parseUnsignedInt(s,2)将字符串转为二进制整数
方法二：
	模拟二进制转十进制过程，从二进制的右边第一个数开始，==每一个乘以2的n次方==，n从0开始，每次递增1。然后得出来的每个数相加即是十进制数。

### 移除重复节点

移除未排序链表中的重复节点。保留最开始出现的节点。

方法一：
	双重遍历，不使用额外空间
方法二：
	数组或者HashMap保存，使用双指针

### 回文链表

请判断一个链表是否为回文链表。

1. 使用栈
   	先遍历一边链表，存入栈中，再遍历一边链表和弹栈出的元素比较
2. 快慢指针
   	快慢指针取得链表中间结点，==翻转后半部分链表==，==最后要翻转回来==

### 链表相交

编写一个程序，找到两个单链表相交的起始节点。

方法一：
	先遍历一边两个链表，存入栈中，根据弹栈判断两个节点是否相等
方法二：
	==每个链表走两边==，如果相交之前走的路径就一样

```java
while(l1 != l2){
    l1 = (l1 != null) ? l1.next:headB;
    l2 = (l2 != null) ? l2.next:headA;
}
```

### 删除中间节点

只能访问要删除的节点
方法一：
	将后个节点的val值赋给当前节点，再设置当前节点的next

### ×删除排序链表中的重复元素 II

给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 *没有重复出现* 的数字

1. 创建哑结点

   使用一个curr指针，移动到要删除的前一个（判断它的next和next.next），然后创建一个临时指针，让它移动到删除的最后一个（判断它和它的next）

### 链表中倒数第k个节点

方法一：
	先遍历一边链表，存入栈中
方法二：
	先遍历一边，记录长度，后根据长度再遍历一边
方法三：
	双指针，==快指针先走K步==

### ×反转链表 ###
1. 非递归

   ==**先判断链表是否为环!!!，先要判断是否为null，和next是否为null!!!**==
   	需要三个节点，prev，curr，用于交换的temp	

2. 递归

   ==假设返回的就是翻转好的链表==，head指向的是翻转完成的前一个节点，head.next.next = head;  head.next = null;

### 反转链表 II

反转从位置 m 到 n 的链表

1. 先移动到位置m，取得要翻转的个数，与反转链表同样的方式，先将prev，curr放到m的值，纪录好此时的位置，最后调整

### ×✔K 个一组翻转链表

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

1. 创建dummy避免判断，使用prev待翻转链表的前驱，tail表示待翻转链表的末尾

   每次让tail向后移动k个，==然后保存tail.next，把它置空。==

   翻转prev.next  - tail的链表，==翻转后会颠倒==，prev变为头，curr的变为尾，再将它们拼接起来
   
   ==注意：中间移动后如果为null，要break出循环==


### 删除链表的节点

注意：
	删除的节点为首节点或者尾节点

### ✔删除链表的倒数第N个节点

给定一个链表，删除链表的倒数第 *n* 个节点，并且返回链表的头结点。

1. 一次遍历

   建立哑结点，快慢指针，快指针先走n个节点，然后快慢指针一起走，快指针走到头时，慢指针就指向了倒数第N个节点的前一个

### 两两交换链表中的节点

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

方法一：
	三指针，建立哑结点，临时节点用于交换的temp

2. 递归，
   从链表的头节点 head 开始递归。每次递归都负责交换一对节点。由 firstNode 和 secondNode 表示要交换的两个节点。

   下一次递归则是传递的是下一对需要交换的节点。若链表中还有节点，则继续递归。

   交换了两个节点以后，返回 secondNode，因为它是交换后的新头。在所有节点交换完成以后，我们返回交换后的头，实际上是原始链表的第二个节点。

### 旋转链表

将链表每个节点向右移动 k 个位置

方法一：
	先取得链表长度，将n-k节点处，断开，重新拼接链表
方法二：
	先取得链表长度，==将链表成环==，将n-k断开，返回头结点即可（避免空指针）

### 分隔链表

使得所有小于 x 的节点都在大于或等于 x 的节点之前

1. 新开辟链表
   分成两个链表，小于x的为一个链表，大于等于x的为另一个链表，将两个链表进行拼接

### 奇偶链表

​	同：分隔链表

### 分隔链表

编写一个函数以将链表分隔为 `k` 个连续的部分。

1. 获得链表长度，使用长度与分割数量求出每部分链表长度

### 链表组件

列表G是链表中整型值的一个子集，返回列表 G中组件的个数。链表中一段最长连续结点的值（该值必须在列表 `G` 中）构成的集合
方法一：
	设置连续标记，判断列表G是否包含链表节点（循环遍历数组）
方法二：
	同方法一（使用HashSet判断）
方法三：
	不必使用连续标记，当前节点包含，而下一个节点不包含时（连续标记也是这种思想）找到了一个组件（使用HashSet判断）
方法四：
	同方法三（使用桶排序，空间换时间）

### 设计链表

注意：
	1.初始化首尾哑结点，避免判断空指针
	2.在添加、删除时不要直接使用head和tail
	3.在进行index时，首节点有一个额外的路程
	4.双向链表判断离首节点近还是尾节点近

### ×环形链表

给定一个链表，判断链表中是否有环。

1. 快慢指针

   如果快指针为null，说明不存在环，如果存在环则快慢指针会相遇
   
   ==快指针设为head.next，如果快指针设为head，循环不会进去==，或者改为while(true)

### ×环形链表 II

返回链表开始入环的第一个节点

1. Set
   使用Set保存已经访问过的节点，遍历整个列表并返回第一个出现重复的节点。

2. 快慢指针

   - 快慢指针判断有无环存在，有环的话，将两个环相遇的位置记为X
   - 从头部和X再出发，相遇的点就为入环的第一个节点

   ==快慢指针需要从head出发，循环条件为while(true)==

### 重排链表

L0→L1→…→Ln-1→Ln ，变为，L0→Ln→L1→Ln-1→L2→Ln-2→…

1. 快慢指针	

   - 找到中间节点，分为左右两个部分（把中间节点归到左半部分）
- 翻转右半部分链表
   - 将左边和右边插入到一起

### 合并两个排序的链表

输入两个递增排序的链表l1, l2，合并这两个链表并使新链表中的节点仍然是**递增排序**的

1. 建立哑结点

2. ==递归==

   ==假设递归返回的是合并好的链表==

   - 如果l1的值小于l2的值，那么把的下一段送去跟l2排序

     l1.next = 递归(l1.next, l2)

   - 如果l1的值大于等于l2的值，那么把l1送去跟l2的下一段排序

     l2.next = 递归(l1, l2.next)

   递归的终止条件：

   - l1为null， 返回l2
   - l2为null， 返回l1

### 合并两个排序的链表 Ⅱ

输入两个递增排序的链表l1, l2，合并这两个链表并使新链表中的节点改为是**递减排序**的

1. 头插法

   建立哑结点，循环条件终止条件为`l1==null && l2 == null`，如果有一个为空，==就把他的值设置为int最大值，以便能比较==

   ```java
   ListNode temp = l1.next;
   l1.next = dump.next;
   dump.next =l1;
   l1 = temp;
   ```

### ×合并K个排序链表

合并 *k* 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度

1. 使用小根堆

   维护一个小根堆，把初始节点加入到堆中，创建dummy哑结点，不断的同堆中拿出最小的节点，往后拼接，并且拿出的节点的后一个加入到堆中

2. 并归合并

   两两进行并归合并，==时间复杂度O(NKlogK)，因为合并时候链表不断变长==

### 链表插入排序

方法一：
	设置哑结点，每次在要插入的链表中取出一个节点，循环遍历被插入的节点进行比较
方法二：
	方法一没有利用到链表中存在的顺序，如果后一个节点本来就比前一个节点大，就没必要移动。在移动时，将要移动的点拿出来，把原先链表连接好，在把移动的点插入到链表中就可以。

### 链表并归排序

O(n log n) 时间复杂度、(1)空间复杂度（不能使用递归）
方法一：
	递归。
	1.分割。快慢指针找到链表中点进行切割，当链表只有一个点时，递归终止
	2.合并。建立哑结点，双指针指向两链表头部，进行插入
方法二：
	迭代。
	1.确定链表长度
	2.以进行倍速遍历（2，4，8），在遍历过程中，进行拆分，合并

### 深拷贝带随机指针的链表

方法一：
	迭代。使用==HashMap维护旧链表与新链表的关系==
方法二：
	递归（回溯）。把链表看成一个图，遍历按照深度优先进行
方法三：
	O(1)空间复杂度。

1. 创造出一个旧节点和新节点交错的链表
2. 迭代这个新链表，并用旧节点的 random 指针去更新对应新节点的 random 指针
3. 将新链表拆分为原链表和复制好的链表

### 从链表中删去总和值为零的连续节点

方法一：

1. 建立一个HashMap，遍历链表，将sum作为key，node作为value。
2. 再次遍历，若当前节点处sum在下一处出现了则表明两结点之间所有节点和为0，直接删除区间所有节点
   方法二：
   	