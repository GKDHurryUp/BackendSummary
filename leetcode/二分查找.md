## 二分查找模版

==左侧逼近==： `mid` 被分到左边。即区间被分成 `[left, mid]` 与 `[mid + 1, right]`，此时取中间数的时候**下取整**。

```java
while(left < right){
    int mid = (left + right) >>> 1;
	if (check(mid)) {
    // 下一轮搜索区间是 [mid + 1, right]
    	left = mid + 1;
	} else {
   		right = mid;
	}	
}
```

==右侧逼近==： `mid` 被分到右边。即区间被分成 `[left, mid - 1]` 与 `[mid, right]`，此时取中间数的时候**上取整**。

```java
while(left < right){
    int mid = (left + right + 1) >>> 1;
	if (check(mid)) {
     	// 下一轮搜索区间是 [left, mid - 1]
    	right = mid - 1;
	} else {
   		left = mid;
	}	
}
```

<img src="C:\Users\Administrator\Desktop\春招\总结\imgs\二分查找.png"  />

### x 的平方根

实现 `int sqrt(int x)` 函数。

1. 二分查找

   左边界设置0，右边界设置为x

###  0～n-1中缺失的数字

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

1. 排序数组中的搜索问题，使用 **二分法** 

   - **左子数组：**
     $$
     nums[i] = i
     $$

   - **右子数组：** 
   $$
   nums[i] \ne i
   $$


### 统计有序矩阵中的负数

给你一个 `m * n` 的矩阵 `grid`，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。 统计 `grid` 中 **负数** 的数目。

1. 二分查找

   找到每行中从前往后的第一个负数

2. 二分查找优化

   无论是==按行还是按列==都非递增，因此可以在第一次二分查找时，返回最右界，下一次的二分查找肯定位于0~上一次最右，对于后面的遍历即可

### ==方阵中战斗力最弱的 K 行==

给你一个大小为 m * n 的方阵 mat，方阵由若干军人和平民组成，分别用 1 和 0 表示。

请你返回方阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。

如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。

军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。

1. 在方阵中，每排进行二分搜索，统计军人的数量，使用Map将索引作为key，军人数量为value。对Map以value进行排序，取前K个.

2. 在方阵中，每排进行二分搜索，统计军人的数量，把==索引信息==与军人的数量==编码后==放入数组中，对数组进行排序，然后将前K个索引信息解码出来

   根据题目条件限制：

   - 编码：**军人数量 * 100 + 索引信息**
   - 解码：**%100**

------

### ==×==供暖器

给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。

1. 二分查找

   ==对于每个房屋，二分搜索供暖器==，找到距离最短的供暖器，返回最短距离

   对于二分搜索开始之前做出判断

   - 比最大值大
   - 比最小值小

   这两种情况，直接返回最短距离，最后返回left和right到目标距离的小的那个

### 两个数组间的距离值

给你两个整数数组 arr1 ， arr2 和一个整数 d ，请你返回两个数组之间的 距离值 。

「距离值」 定义为符合此距离要求的元素数目：对于元素 arr1[i] ，不存在任何元素 arr2[j] 满足 |arr1[i]-arr2[j]| <= d 。

1. 暴力

2. 二分查找

   先对arr2进行排序，遍历arr1，==对每一个arr1元素二分查找arr2==

   采用二分模版，采用右侧逼近，找到大于等于arr1元素的第一个index位置，检测index和index1即可

------

### 魔术索引

魔术索引：在数组`A[0...n-1]`中，满足条件`A[i] = i`。

如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。

1. O(n)遍历

2. 二分思想

   如果找到值，则从左半边继续查找更小的解。如果未找到，则先搜索左半边，左半边无解的情况下再搜索右半边


### 找出给定方程的正整数解

给出一个函数 `f(x, y)` 和一个目标结果 `z`，请你计算方程 `f(x,y) == z` 所有可能的正整数 **数对** `x` 和 `y`，函数是严格单调的

1. 二分查找

   遍历所有的x，对y进行二分搜索

------

### 山脉数组的峰顶索引

给定一个确定为山脉的数组，满足 A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1] ，求 i 的值。

1. 二分查找

   判断A[mid]，A[mid+1]，A[mid-1]

### 山脉数组中查找目标值

给你一个 **山脉数组** `mountainArr`，return the **minimum** `index`such that `mountainArr.get(index) == target`

1. 多次二分查找
   - 先二分找到山顶，根据山顶分为左右两边有序数组
   - 先对左边数组二分，后对右边数组二分

### ××搜索旋转排序数组

假设按照升序排序的数组在预先未知的某个点上进行了旋转。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。你可以假设数组中不存在重复的元素。

1. 二分查找

   将数组一份为二，==其中一份肯定有序，一份可能有序==

   如果target在有序部分，则二分查找，如果在无序部分，则继续一分为二

2. 转化有序数组

   先二分查找到旋转点，分为两部分有序数组，在对有序数组进行二分查找

   ==若旋转点为0，需要单独判断防止越界==

### ×搜索旋转排序数组 II

假设按照升序排序的数组在预先未知的某个点上进行了旋转。编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 `true`，否则返回 `false`。（存在重复）

1. 二分查找

   将数组一份为二，其中一份肯定有序，一份可能有序

   ==如果相等，两端向中间压缩==，使用while简化代码

------

### 稀疏数组搜索

稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。

1. 二分查找，mid值单方向靠拢

   由于是稀疏的，要排除“”的元素，当二分法的mid元素为“”，则挑一个方向靠拢，比如向右，以第一个不为“”的元素作为mid。

   当mid值超过right边界时，说明mid以右不存在答案，转而搜索mid左边的部分，即使right = ((left + right) >>> 1) -1;

### ×旋转数组的最小数字

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。

1. 贪心

   遍历整个数组，遇到前一个比后一个大就直接返回

2. 二分查找

   - 如果中间的比右边的大，那么最小的值不可能在左边

     left = mid + 1；

   - 如果中间的和右边的相等，那么只能排除一个

     right = riht -1；

   - 如果中间比右边小，那么就往左边查找

     left = mid；

### 在排序数组中查找元素的第一个和最后一个位置

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

1. O(n)遍历

2. 二分查找

   进行两次二分查找，第一次从==左侧向右侧==逼近，找到一个出现的位置，第二次从==右侧向左侧==逼近，找到最后一个位置

### ×在 D 天内送达包裹的能力

传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。

传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。

返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力

1. 二分查找

   首先找到能运送的最低能力为sum / D， 最高能力为sum

   不断二分查找判断，mid = （minCarry + maxCarry）>>> 1

   ==判断条件为，根据运载能力能否在D天之内运送完成==