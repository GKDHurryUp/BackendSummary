## 递归技巧
1. 写出结束条件
2. 不要把树复杂化，就当做树是三个节点，根节点，左子节点，右子节点
3. 只考虑当前做什么，不用考虑下次应该做什么
4. 每次调用应该返回什么，传入参数应该接收什么

## 一、树的基本操作

### 二叉树前序遍历，中左右

1. 递归：
   	在root.leflt和root.right之前
2. 迭代：
   	使用栈，入根节点之后，先右节点，后入左节点

### ×二叉树中序遍历，左中右

1. 递归：
   	在root.leflt和root.right之间
2. 迭代：
   	使用==栈==，需要有一个curr节点配合，先将curr所有左子节点入栈，再将curr更新curr的右子节点。	

### 二叉树后序遍历，左右中

1. 递归：
   	在root.leflt和root.right之后
2. 迭代：
   	如果是从左子树到的根节点，此时应该转到右子树。
      	如果是从右子树到的根节点，那么就可以把当前节点弹出，并且加入到list。
      	通过记录上一次遍历的节点。如果当前节点的右节点和上一次遍历的节点相同，那就表明当前是从右节点过来的了。可以把当前节点弹出，并且加入到 list 中。

3. 前序反序
   	使用前序遍历的变种，中右左，将结果添加到入到栈中，反向输出，即可得到左右中

4. 巧解
   	把每个节点 push 两次，然后判断当前 pop 节点和栈顶节点是否相同。

   相同的话，就意味着是从左子树到的根节点。不同的话，就意味着是从右子树到的根节点，此时就可以把节点加入到 list 中。



### N叉树的前序遍历

先添加，再进行递归操作

### N叉树的后序遍历，左右中

先递归，再添加

### 二叉树的最大深度 ###

1. 递归返回的时当前节点的最大深度，它等于==左右子树的最大值+1==

### 二叉树的最小深度 ###
1. 使用递归参数
	更改递归函数入口， 加入一个深度变量，递归调用时每次加一，没有返回值
2. 使用递归返回值
	函数返回值为该节点的最小深度，如果左右子树都为空或者==有一方为空==，则直接返回两者的深度 + 1即可。
	若都不为空就选两者最小的深度 + 1 

### ✔判断平衡二叉树 ###

输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

1. 实质还是求树高度的问题
   当前节点的高度，等于max(左子树，右子树)+1

   维护一个标记，如果出现深度相差超过1，就置为false

### N叉树的最大深度 ###

方法一：
	定义：递归返回的是当前节点的深度=子节点深度+1

### 二叉树的堂兄弟节点

取得父节点方式：
	递归函数要增加一个参数，保存父节点，递归调用时传入当前节点
取得每个节点深度的方式：
	使用一个HashMap，将每一个节点做为Key，深度作为value。插入时，将父节点的深度+1

### 二叉树转为链表I ###

先root，后左子树，后右子树

1. 递归

​	先遍历右子树

2. DFS
   	迭代。深度优先遍历

### 二叉树转为链表II ###

先左子树，后root，后右子树

方式一：
	递归。中序遍历，将节点left置空，

### 递增顺序查找树 ###

给你一个树，请你 **按中序遍历** 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。

1. 中序遍历
   建立哑结点，依次加入，记录前一个节点

### 二叉树中第二小的节点 ###

方法一：
	建立HashSet，遍历树节点放入HashSet中，返回第二个值
方法二：
	求左右子树的最小值，不需要HashSet

### 左叶子之和 ###

计算给定二叉树的所有左叶子之和

思想：
	求所有节点之和->求所有叶子节点之和->所有左叶子节点之和
	使用==参数标记是否为左子树==

### 叶子相似的树 ###

一颗二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 *叶值序列* 

如果有两颗二叉树的叶值序列是相同，那么我们就认为它们是 *叶相似* 

方法一：
	将叶子添加到两个List中，比较两个List是否相等

### 根据二叉树创建字符串 ###
方法一：
	前序遍历，拼接字符串，根据左右子树是否为空，拼接括号

### ×二叉树的所有路径 ###
1. 递归
	递归参数加入字符串，参数需要额外变量，把当前节点的值拼入字符串中，传给左右子树时==每次需要new一个字符串==
2. 优化
	使用StringBuilder代替String，防止频繁构建新的String对象
	注意在参数传递时，要new一个新的

### 路径总和 ###
判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和

思想：
	如果当前节点不是叶子，使用 sum 值减去当前节点的权值，传给它的所有孩子节点；
	如果当前节点是叶子，检查 sum 值是否为 0，也就是是否找到了给定的目标和。

### 路径总和 II

找到所有从根节点到叶子节点路径总和等于给定目标和的路径
思路：
	维护一个全局List，使用前序遍历，将每一个节点的值加入到List中，同时将sum 值减去当前节点的权值。判定叶节点是否`sum==0`，是的话把新建一个List存入结果中。==每次节点操作完成，需要在维护的全局List去掉当前节点==

### ×路径总和 III

路径不需要从根节点开始，也不需要在叶子节点结束

1. 双递归

   第一个递归遍历整个树，第二个递归以当前节点为root，向下搜索，返回找到的数量。(也可以定义返回值为void，使用成员变量记录)

2. 前缀和

   ==如果两个数的**前缀总和**是相同的，那么这些**节点之间的元素总和为零**。==

   如果前缀总和sum，在节点A和节点B处相差target，则位于节点A和节点B之间的元素之和是target。
   利用一个HashMap维护前缀和sum，以及出现的次数。
   注意：
   		1.前缀和要加入0节点，避免条件判断。
   		2.回到本层，恢复状态，要去除当前节点的前缀和数量。如果不做的话，前序遍历，左结点加入的sumCount的结果可能会影响右节点的判断。
   		3.不可以删除，如果加入之前有节点相加的值正好等于要删除的值，会出错

### ×二叉树中的最大路径和

给定一个**非空**二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径**至少包含一个**节点，且不一定经过根节点

1. 递归
   - 递归返回的是当前节点为根节点所贡献的最大值
   - 递归出口为null，返回0，贡献0
   - 本节点返回，左右子树的最大值（不能为负数） + 本层的节点值
   - 左右子树的值如果是负数，要置为0
   - 答案需要更新每一个节点，求最大值

### ×最长同值路径 ###

给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。

1. 递归
	
	递归返回的是：以当前节点为根的，==向左延伸的最长箭头==的长度（leftLen）和==向右延伸的最长箭头的长度==（rightLen）
	这个值（也就是递归最后返回的值）等于max(左子树的返回值, 右子树的返回值)
	在递归过程中，维护一个变量更新
	res = Math.max(res, leftLen + rightLen);

### 相同的树

给定两个二叉树，编写一个函数来检验它们是否相同。

方法一：
	递归挨个判断即可

### 另一个树的子树 ###

给定两个非空二叉树 **s** 和 **t**，检验 **s** 中是否包含和 **t** 具有相同结构和节点值的子树。

1. 双递归
   	递归遍历大树的每一个节点，再递归比较大树的每一个节点和子树的每一个节点

2. 字符串比较

   前序遍历两个树，把结果放在两个字符串中，判断大树的字符串是否含有子树的字符串

### 树的子结构

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

1. 双递归

   递归A的每一个节点，再递归比较A和B每一个节点，==若A的子树不为空，而B的子树为空，也可以认为是相同结构==

### 二叉树的坡度

一个树的**节点的坡度**定义即为，该节点左子树的结点之和和右子树结点之和的**差的绝对值**。

1. 递归

   累加每个节点的坡度，递归**返回左右子树节点之和**

### 求根到叶子节点数字之和 ###

给定一个二叉树，它的每个结点都存放一个 `0-9` 的数字，每条从根到叶子节点的路径都代表一个十进制数字。计算从根到叶子节点生成的所有数字之和。

1. 修改递归参数，添加节点值，每下一层等于上一个节点的值*10+当前节点的值

### 从根到叶的二进制数之和

方法一：
	每进一层，num = num * 2 + root.val; 模拟2进制转为十进制，到叶子时相加	

### ×寻找重复的子树 ###

给定一棵二叉树，返回所有重复的子树。

1. 序列化二叉树
DFS遍历树，==把每个节点所代表的树序列化==的值作为key存入HashMap中，出现的次数为value，如果遇到了重复的key则说明找到了重复子树
2. 唯一标识符 
假设每棵子树都有一个唯一标识符：只有当两个子树的 id 相同时，认为这两个子树是相同的。
一个节点 node 的左孩子 id 为 x，右孩子 id 为 y，那么该节点的 id 为 (node.val, x, y)
**通过两层HashMap映射，通过把key缩短变为Integer，避免方法一很长的字符串**

### 输出二叉树 ###
在一个 m×n 的二维字符串数组中输出二叉树，m为树的高度，**n为2^树高 -1**
1. 先遍历取得树的高度
2. 初始化二维数组，递归向数组填充值

### ×在二叉树中分配硬币

1. DFS

   定义 `dfs(node)` 为这个节点所在的子树中金币的 *过载量*，也就是这个子树中金币的数量减去这个子树中节点的数量

   - 则一个节点需要移动的次数为左子树的*过载量* + 右子树的*过载量*

## 二、层序遍历 ##

### 二叉树的层序遍历

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。

1. BFS

   ==取得队列的大小后进行for循环==，添加即可

### 二叉树的层次遍历 II ###

给定一个二叉树，返回其节点值自底向上的层次遍历。

1. BFS

   取得队列的大小后进行for循环，使用LinkedList的addFirst即可

### 二叉树的锯齿形层次遍历

请实现一个函数按照之字形顺序打印二叉树，先从左往右，再从右往左

1. BFS

   取得队列的大小后进行for循环，使用LinkedList，添加一个额外变量，为true时，用addLast方法，为false时，用addFirst方法

### 二叉树的层平均值 ###
1. BFS
	建立一个Queue<TreeNode> temp（可以使用for循环在原队列上进行操作，把当前层的节点弹出，加入下一层的节点），来保存树一层的数据
2. DFS
	需要保存树的高度，根据高度更新sum数组和cnt数组

### 特定深度节点链表

给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 `D`，则会创建出 `D` 个链表）。返回一个包含所有深度的链表的数组。

1. BFS层序遍历

   取得队列的大小后进行for循环，使用链表哑结点，在for循环内构造链表

### 在每个树行中找最大值

1. BFS

   取得队列的大小后进行for循环，每层求最大值即可

### 对称二叉树 ###
方法一：
	层次遍历，==**看成两棵树**==，要想到把一个节点加入队列两次
方法二：
	深度遍历，**看成两棵树**

​	左右颠倒互相判断

### 填充每个节点的下一个右侧节点指针 ###

给定一个**完美二叉树**，其所有叶子节点都在同一层，每个父节点都有两个子节点。填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

1. 层序遍历

   在队列中，让==node.next 指向 q.peek()==

   

### ×二叉树中所有距离为 K 的结点

给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。

1. DFS+BFS

   ==先进行DFS把所有节点的父节点放入Map中==（此时相当于构造了一个图），进行BFS搜索，层数等于K时返回



### 二叉树的右视图

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

1. BFS

   如果遍历到每一层最右边即i-1则，把节点添加到List中

2. DFS

   使用depth存储每层高度，按中右左的顺序遍历，如果到达新的一层，就把当前节点加入List

### 找树左下角的值

给定一个二叉树，在树的最后一行找到最左边的值。

1. BFS

   BFS遍历树，使用一个变量记录每层第一个值，遍历完成后，这个值就是最后一层最左边的值

### 二叉树最大宽度

给定一个二叉树，这个二叉树与**满二叉树（full binary tree）**结构相同，但一些节点为空。

每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的`null`节点也计入长度）之间的长度。

1. BFS

   更改树节点结构，加入位置信息：

   从0开始编号，==**一个节点的位置为k，则左子节点的位置为2k+1，右子节点位置为2k+2**==

   通过层序遍历取得每一层的的宽度(最后一个位置减去第一个位置)

### 最小高度树

对于一个具有树特征的无向图，我们可选择任何一个节点作为根。图因此可以成为树，在所有可能的树中，具有最小高度的树被称为最小高度树。给出这样的一个图，写出一个函数找到所有的最小高度树并返回他们的根节点。

1. 多源BFS

   ==找到所有度为1的节点，从外向内搜索==，使用degree[]来存储度，==每次遍历度为1的节点==，最后剩余的就是中心节点，每次遍历到节点就让它度-1，**同时可以省去visited[]数组**



## 三、BST 二叉搜索树 ##

看到BST，要想到利用中序遍历（左中右）来利用它的排序特性，以及唯一特性

### ×验证二叉搜索树

1. 前序遍历（错误的）

   只验证左右孩子的值和父节点的值是错误的

2. 中序遍历

   使用prev保存前一个节点的值，中序遍历树，若当前节点的值大于prev，返回false

### 二叉搜索树中的搜索 ###

给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。

1. 递归
   	如果等于当前节点值则返回，若比当前节点小，进入左子树搜索，若比当前节点大，进入右子树 搜索。

### 二叉搜索树的第k大节点

给定一棵二叉搜索树，请找出其中第k大的节点

1. 递归

   中序遍历的变体，右左中，记录遍历到第K个节点返回即可

### 两棵二叉搜索树中的所有元素

给你 `root1` 和 `root2` 这两棵二叉搜索树。

请你返回一个列表，其中包含 **两棵树** 中的所有整数并按 **升序** 排序。.

1. 遍历两棵树，进行排序
2. 中序遍历+并归排序

### ×二叉搜索树的最近公共祖先 ###
1. 遍历树

   将每个节点的父节点找出来，问题转换为求==两个链表相交的节点==

2. 递归
    定义递归返回的就是答案，即最近公共祖先节点。利用二叉搜索树的特性，
    若节点 p 和节点 q 都在右子树上，那么以右孩子进行递归；
    若节点 p 和节点 q 都在左子树上，那么以左孩子进行递归；
    否则就找到了答案

### ✔✔二叉树的最近公共祖先 ###

给定一个二叉树, 找到该树中两个指定节点p，q的最近公共祖先。

1. 使用上一题的1

2. 后序遍历
	
	两种情况：
	
	- 如果当前节点的左孩子包含一个目标节点，右孩子包含另一个目标节点，那么这个节点就是它们的最近公共祖先。
	- 当前节点为目标节点，而当前节点的孩子包含了另一个目标节点，那么这个节点就是它们的最近公共祖先
	
	==找到节点p或者q时，就让它返回==
	
	查看每个节点的左子树与右子树的返回值，如果都不为null，说明root就是最近公共祖先
	
	如果有一个子树的返回值为null，说明当前子树没有包含，直接返回另一颗子树

### 二叉搜索树中的众数 ###
二叉搜索树不存在相同值的结点，本题特别强调了可以存在
方法一：
	遍历树，把每一个节点的值作为key，次数作为val，加入到HashMap，再遍历HashMap得到众数
方法二：
	中序遍历，保证遍历时的有序性，保留上一个节点prev，判断prev的值和当前值增加次数

### 二叉搜索树的最小绝对差 ###
方法一：
	中序遍历，**保留上一个节点prev**，记录prev的值和当前值的相差最小

### 把二叉搜索树转换为累加树 ###

给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。

方法一：
	==反序中序遍历==，逐个累加

### 二叉搜索树的范围和 ###

返回 L 和 R（含）之间的所有结点的值的和。
方法一：
	前序遍历。如过当前节点值小于L，返回右子树的范围和，如果大于R,返回左子树的范围和。

### 两数之和IV-输入BST ###

给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。

方法一：
	先反序中序遍历，后再递归遍历。（时间很长）
方法二：
	使用HashSet，在HashSet中检查是否存在k-root.val

### 在二叉树中增加一行 ###

给定一个二叉树，根节点为第1层，深度为 1。在其第 `d` 层追加一行值为 `v` 的节点。

1. BFS
	在d-1层，添加修改节点结构，注意要先把下一层的节点添加到队列后再进行修改

### 二叉搜索树的后序遍历序列

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同

1. 递归

   后序遍历，左右中，最后一个为根节点，通过左右指针，来标记左子树、右子树。==第一个大于根节点的位置就是右子树开始的位置==

### ×有序链表转换二叉搜索树

给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

1. 递归

   快慢指针找到中点，并且断开链表，然后递归进行构造

2. 递归+转为数组

   将链表转为数组，使用空间换时间

3. 中序遍历

   - 遍历整个链表获得它的长度
   - 使用两个指针标记结果数组的开始和结束，找到中间元素
   - 我们当前需要模拟中序遍历，找到中间元素 (start + end) / 2。注意这里并不需要在链表中找到确定的元素是哪个，只需要用一个变量告诉我们中间元素的下标。我们只需要递归调用这两侧

   - 递归左半边（start， mid-1）
   - 移动链表
   - 递归右半边（mid+1，right）

### ×恢复二叉搜索树

二叉搜索树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。

1. 中序遍历

   中序遍历搜索树，使用两个变量记录出现逆序的信息，使用prev保存上一个节点的信息

   当prev.val > root.val时说明出现问题，保存节点信息

   ==注意：有可能是紧挨着的两个节点错乱，在保存了第一个节点后要继续保存第二个节点==

### ×二叉搜索树中的插入操作

给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。

1. 递归

   ==定义递归返回的就是修改好的子树==，如果当前节点值小于给定值，那么修改左子树，否则修改右子树

## 四、修改树的结构 ##

### 修剪二叉搜索树

给定一个二叉搜索树，同时给定最小边界`L` 和最大边界 `R`。通过修剪二叉搜索树，使得所有节点的值在`[L, R]`中

方法一：

​	前序遍历。注意要想清楚==递归返回的已经修建好的子树==。如过当前节点值小于L，返回(修剪好的)右子树，如果大于R,返回(修剪好的)左子树。

方法二：
	后序遍历。

### ✔二叉树的镜像

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

1. 递归

   ==递归返回的已经修建好的子树==，将左子树置为返回的右子树，右子树置为返回的左子树

   ==注意：中间变量保存左子树/右子树==

### 将有序数组转换为二叉搜索树 ###

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

1. 递归创建

   类似并归排序的思想，==递归函数返回的是已经构造好的树==，将下一个递归函数的返回值添加到左右子树

### 翻转二叉树 ###
1. 递归

   ==递归函数返回的是已经翻转好的树==，左右互换，使用中间节点**临时存放节点**

### 合并二叉树 ###

给定两个二叉树，将他们合并为一个新的二叉树。

合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则**不为** NULL 的节点将直接作为新二叉树的节点。

1. 递归
	
	==递归函数返回的是已经合并好的树==，要改变树的结构，一定要改变left,right节点。返回值是左右子树，将当返回值作为前节点的左右子树。如果有一棵树为空，返回另一颗树。

### ✔××从前序与中序遍历序列构造二叉树 ###

==**前序找root，中序分左右**==

- **将中序数组放入Map维护**，key为节点，value为数组的索引，构造一个节点时，它的中序遍历数组的[left, index-1]就是左子树，[index+1, right]就是右子树
- 前序数组维护一个指针，每次递归指针+1，使用后序数组要==先构造左子树，再构造右子树==

### ✔××从中序与后序遍历序列构造二叉树 ###
==后序找root，中序分左右==

- **将中序数组放入Map维护**，key为节点，value为数组的索引，构造一个节点时，它的中序遍历数组的前一个就是左子树，中序遍历数组的后一个就是右子树
- 后序数组维护一个指针，每次递归指针-1，使用后序数组要==先构造右子树，再构造左子树==

### ×根据前序和后序遍历构造二叉树

前序后有序有都能快速找到root，但是左右子树不好确定

1. 

2. ==优先构建子树==

   **利用前序遍历来构建Tree，然后通过后序遍历来检验当前树是否构建完毕**

   初始化preIndex = 0, posIndex = 0;

   前序遍历依次创建，通过创建出的节点，当 `root.val == post[posIndex]`时, 意味着我们已经构建完毕了当前子树，posIndex ++

### 先序遍历构造二叉树

返回与给定先序遍历 `preorder` 相匹配的二叉搜索树（BST）的根结点。

1. 排序

   先排序生成中序遍历，根据中序遍历生成二叉树

2. 递归

   不需要排序的信息，根据节点的值来判断，放入左子树或右子树是否合适。

   初始化左右边界Integer.MIN_VALUE, Integer.MAX_VALUE，递归以当前的val值更新边界

3. 迭代

### ×最大二叉树 ###

一个以此数组构建的最大二叉树定义如下：

- 二叉树的根是数组中的最大元素。
- 左子树是通过数组中最大值左边部分构造出的最大二叉树。
- 右子树是通过数组中最大值右边部分构造出的最大二叉树

1. 递归创建

   ==递归函数返回的是已经创建好的树==，类似并归排序的思想，每次找出数组中的最大元素以及下标，将下一个递归函数的返回值添加到左右子树

注意：传入的边界，以及递归出口的判定

### ×二叉搜索树与双向链表

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向

1. 中序遍历

   使用==prev保存前一个节点==，将prev和root连接成双向链表，同时需要==head保存第一个遍历==的节点，最后改变prev和head形成循环链表

### 删除给定值的叶子节点

给你一棵以 `root` 为根的二叉树和一个整数 `target` ，请你删除所有值为 `target` 的 **叶子节点** 

注：一旦删除值为 `target` 的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是 `target` ，那么这个节点也应该被删除。

1. 采用后序遍历

   这样对于二叉树中的每个节点，它的子节点一定先于它被操作

### 删点成林

给出二叉树的根节点 `root`，树上每个节点都有一个不同的值。如果节点值在 `to_delete` 中出现，我们就把该节点从树上删去，最后得到一个森林

1. 采用后序遍历

   删除该节点，同时修改树的结构，如果左(右)子树不为null就把它添加到结果集中，最后记得要判断root节点是否加入到结果集
   
   

## 五、完全二叉树

### ×完全二叉树的节点个数

除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。

1. 线性遍历

   递归一个一个的计算节点

2. 二分查找

   最后一层的叶子节点都靠左边，可以使用二分查找确定个数

   **树的高度，可以通过左子节点求出**

   确定最后一层叶子节点是否存在，用到了两次二分，对应搜索路径以及最后一层叶子节点

3. ==递归==

   ==递归返回的就是二叉树节点个数==，对root节点的左右子树高度，left，right进行统计

   - 若相等，说明是左子树是满二叉树，且左子树的节点个数为2^left，再对右子树递归统计
   - 若不相等，==说明最后一层不满，但倒数第二层已经满了==，可以直接得到右子树的个数，即为2^right，再对左子树递归统计

### 二叉树的完全性检验

给定一个二叉树，确定它是否是一个*完全二叉树*

1. dfs+bfs

   先dfs遍历节点，给每一个节点编号，存入Map中，然后使用bfs遍历， 同map中取出序号，查看是否是连续的

2. bfs

   按bfs入队列，==把null值也加入到队列中==，遇到null值，就跳出遍历

   判断剩余队列中是否含有非null值，若有则不是二叉完全数

### ×所有可能的满二叉树

满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。

返回包含 `N` 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。

1. 递归+记忆化

   为左子树分配 `x` 节点，为右子树分配 `N - 1 - x`节点，（加上根节点一共就是N个节点）

   

## 六、树中的动态规划

### ×二叉树中的最长交错路径

给你一棵以 root 为根的二叉树，二叉树中的交错路径定义如下：

选择二叉树中 任意 节点和一个方向（左或者右）。
如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。
改变前进方向：左变右或者右变左。
重复第二步和第三步，直到你在树中无法继续移动。
交错路径的长度定义为：访问过的节点数目 - 1（单个节点的路径长度为 0 ）。

请你返回给定树中最长 交错路径 的长度

1. dfs

   从根节点开始，进行两个方向递归。

   - 在递归中，使用一个标志位，来控制向左或向右递归
- 若和上一个方向相同，则长度置为1
   - 若和上一个方向不同，则长度+1

### ×节点与其祖先之间的最大差值

给定二叉树的根节点 `root`，找出存在于不同节点 `A` 和 `B` 之间的最大值 `V`，其中 `V = |A.val - B.val|`，且 `A` 是 `B` 的祖先。

1. dfs

   使用全局变量保存最大差值，进行dfs，每次递归查找当前路径的最大值和最小值，到达叶子节点时使用当前路径的最大值和最小值更新全局变量



## 构造树

给定字符串或者数组，通过栈，或者递归，构造二叉树

### 从先序遍历还原二叉树

在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。

1. 栈

   因为前序遍历 根|左|右 ，==字符串开头的节点是 ROOT，后面的节点可以凭 level 识别父亲 —— 作为儿子，level 要比父亲大，不满足就不是父亲==

   取得每个节点的深度，和value，因为是先序遍历的顺序，把每个节点压入栈，下一个节点来时，根据栈的高度和节点的深度判断是否为栈顶的子节点，如果不是就弹栈直到栈顶的节点满足可以当子节点的父亲，==如果满足就加入左子树==



## Trie树

Trie（前缀树）

- 找到具有同一前缀的全部键值。
- 按词典序枚举字符串的数据集。

1. 自动补全

2. 拼写检查

3. IP 路由 (最长前缀匹配)

4. T9 (九宫格) 打字预测

5. 单词游戏



### 单词替换

现在，给定一个由许多词根组成的词典和一个句子。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。

你需要输出替换之后的句子。

1. 字典树

   构造TrieNode，额外使用word变量，遍历词根，构造字典树，把前缀每个字母加入到字典树中，结尾处的TrieNode把字符串word添加进去。

   在遍历句子，查找单词的字母对应的前缀的末尾

### ✔字典序排数

给定一个整数 *n*, 返回从 *1* 到 *n* 的字典顺序

1. Trie树

   构造TrieNode，将1~n 数字转化为字符串，插入到Trie树中

   使用dfs遍历Trie树，对数字进行解码（传入上一个节点的值，每次*10，再加上索引值就可以求得原数字）

2. dfs

   直接dfs添加数字，每次传入num*10 + i，其中0<=i<10超过了最大n就返回

   注意：start一开始不能为0

### 数组中两个数的最大异或值

给定一个非空数组，数组中元素为 a0, a1, a2, … , an-1，其中 0 ≤ ai < 231 。

找到 ai 和aj 最大的异或 (XOR) 运算结果，其中0 ≤ i,  j < n 。

1. 字典树

   首先遍历一遍数组，将所有字符解析为二进制加入前缀树。再从最左侧的比特位开始逐一处理来构建最大异或值