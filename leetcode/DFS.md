## 排列组合

### ×不同的二叉搜索树 ###

给定一个整数 *n*，求以 1 ... *n* 为节点组成的二叉搜索树有多少种？

1. 递归

   定义左右两个指针left，right，用来标识位置，==让每一个节点当做根节点，左侧数组作为左子树，右侧数组作为右子树==，递归出口为left >= right，并且返回值为1，代表只有一种情况

   在递归中，遍历left到right，作为当前节点不断创建子树，当前节点创建的种类等于 左子树的种类 * 右子树的种类，求所有种类需要把不同节点当都加起来

2. 记忆化+递归

   定义`dp[][]`穷举left和right的状态，并初始化-1

3. 动态规划

   - dp[i]代表长度为i的序列的不同二叉树的个数
   - 初始化，长度为0个数为1，长度为1个数为1
   - #TODO

### ×不同的二叉搜索树 II

给定一个整数 *n*，生成所有由 1 ... *n* 为节点所组成的 **二叉搜索树** 。

1. 递归

   构造一颗二叉搜索树，返回值一个TreeNode即可，而构造多棵二叉树需要返回一个`List<TreeNode>`，以选择不同的根节点，构建不同的树和子树

   - 递归构建左子树，并拿到左子树所有可能的根结点列表`leftTrees`
   - 递归构建右子树，并拿到右子树所有可能的根结点列表`rightTrees`
   - 遍历`leftTrees`和`rightTrees`，将它们每一个拼接到根节点上，并添加到List中
   - ==递归返回时要在List加入一个null，让循环继续进行==

### ××无重复字符串的排列组合

无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同

1. 递归回溯

   每次挑选一位没有出现过的，将字符串向后拼接，==在当前进行了递归之后，要把访问标记修复，同时删除添加的一位字符串==

### ✔全排列

给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

1. 递归回溯

   每次挑选一位没有出现过的，将字符串向后拼接，==在当前进行了递归之后，要把访问标记修复，同时删除添加的一位的数字==

### ×全排列 II

给定一个**可包含重复**数字的序列，返回所有不重复的全排列

1. 递归回溯

   核心：要解决重复问题，我们只要设定一个规则，保证在填第i个数的时候**重复数字只会被填入一次即可**

   先对数组进行排序，==若有重复的数字或者已经访问过的数字，则跳过==，

### ✔组合总和

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

1. 排序+递归回溯

   先对数组进行排序，然后递归进行拼接，==设置一个idx，每次给idx递归传入i的值，同时删除List最后一位==

### ×第k个排列

给出集合 [1,2,3,…,n]，其所有元素共有 *n*! 种排列。按大小顺序列出所有排列情况，给定 *n* 和 *k*，返回第 *k* 个排列

1. 全排列+优先队列（超时）

   先生成全排列，然后加入到最大堆中

2. 全排列+剪枝

   ==计算剩余数字个数的阶乘数，来选择进入的分支==

   - 若k大于此分支要产生的分枝数，则跳过
   - 若小于等于，则进入分支

### 有重复字符串的排列组合

有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合

1. ✔无重复+Set去重

   使用上一题的方法，把结果添加到Set集合中，进行去重

2. ×递归回溯

### ×组合

给定两个整数 *n* 和 *k*，返回 1 ... *n* 中所有可能的 *k* 个数的组合

1. 递归回溯

   遍历可能的搜索起点，==设置的搜索起点要加 1，因为组合数不允许出现重复的元素==，回溯删除添加的数字

2. 递归回溯+剪枝

   **搜索起点有上界**，

   搜索起点的上界 + 接下来要选择的元素个数 - 1 = n

### ××子集（幂集）

给定一组**不含重复元素**的整数数组 *nums*，返回该数组所有可能的子集（幂集），解集不能包含重复的子集

1. 递归

   由于要求生成不重复，所以==每次循环遍历的初始索引都需要+1==，在dfs前添加答案，dfs后移除最后一个

### ×子集 II

给定一个可能包含重复元素的整数数组 ***nums***，返回该数组所有可能的子集（幂集）

1. 使用Set

   按上一题思路，使用Set进行保存

2. ×排序去重

   先对数组进行排序，当遇到相同的元素continue循环

### ✔×括号生成

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合

1. 递归+剪枝

   - 首先递归函数需要的参数为，==需要生成的左括号数量left，右括号数量right==
   - 递归返回生成好的字符串（可以返回void，添加如List中）

- 递归出口为，left为0并且right为0
  - 递归调用，生成左括号，left-1， 生成右括号，right + 1
  - ==剪枝：left > right ，直接return==

### ×计算各个位数不同的数字个数 ###

给定一个**非负**整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x < 10n

1. 动态规划

   dp[i]为i位数的各位数字都不同的数字 x 的个数
   第一位可能的数组有9种，第二位8，7，...，
   dp[i] = dp[i-1] * (11 - i);
   返回求和即可，若果n>10，但是已经没有不重复的了，可以将n=10;

2. 递归

### ✔✔不同路径

一个机器人位于一个 *m x n* 网格的左上角，机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角，问总共有多少条不同的路径？

1. 记忆化+递归

   递归返回值：不同路径的个数，每次递归求出dfs(i-1, j) + dfs(i, j-1)，再使用`dp[][]`存储i, j的答案

2. 动态规划

   - `dp[i][j]`代表以(i, j)为右下角的矩形能有多少条不同路
   - 初始最左边，最上边为1
   - ` dp[i][j] = dp[i-1][j] + dp[i][j-1];`
   - 答案为最右下角

3. 排列组合

   #TODO

###  不同路径 II

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

1. 动态规划
   - `dp[i][j]`代表以(i, j)为右下角的矩形能有多少条不同路
   - 初始最左边，最上边为1
   - 遇到障碍直接continue，否则` dp[i][j] = dp[i-1][j] + dp[i][j-1];`
   - 答案为最右下角

