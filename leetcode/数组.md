# 思想：

1. 双指针

2. 前缀和

3. 从后向前

4. 看见数据范围小，暴力

### ×==三数之和==

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

1. 排序+双指针

   先将数组排序，定义左右双指针，left（k+1），right（n-1）同时固定一个指针k（0~n-2），遍历数组，这三个指针的数相加

   - 小于0，左指针++，并且跳过相同元素
   - 大于0，右指针--，并且跳过相同元素
   - 等于0，添加答案，并且跳过左右指针的相同元素

   ==左指针每次为k+1，右指针每次为最右边==，==k移动到了相同的元素上要跳过==

优化：当k指向的元素大于0，终止循环

### ×三数之和的多种可能

给定一个整数数组 A，以及一个整数 target 作为目标值，返回满足 i < j < k 且 A[i] + A[j] + A[k] == target 的元组 i, j, k 的数量。

由于结果会非常大，请返回 结果除以 10^9 + 7 的余数。

1. 排序+三指针

   先将数组排序，遍历数组下标，对于每个 i，设 `T = target - A[i]`

### ×四数之和

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组

1. 四指针

   i为起点，j为终点，left与right构成滑动窗口

   - i的范围：0~n - 3
   - j的范围：n-1~ i-j>2
   - left <right ，left初始为i + 1， right初始为j - 1

   每一个循环中需要跳过重复的元素，在第一次循环中优化，`最小值*4 `大于target 直接进行下个循环， 第二个循环中，`最大值*4`小于target直接进行下个循环

   - 若sum == target，加入答案，left++，right-- （跳过重复）
   - 若sum < target，left++（跳过重复）
   - 若sum > target，right--（跳过重复）

### 四数相加 II

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 

1. 双重循环+2个Map

   使用两个Map存储，key为两个数组之和， value为出现这个和的次数

   最后遍历一个Map，若key之和为0，将它们的value相乘

2. 双重循环+1个Map

   只需要一Map即可，在第二次循环中，判断出现过key和为0的没有即可

------

### 消失的数字

数组`nums`包含从`0`到`n`的所有整数，但其中缺了一个，找到缺失的数

1. 异或

   数组中的数和0~n的数异或，剩下缺失的数

2. 求和公式

   0~n求和 减去 数组元素求和

### 数组中数字出现的次数

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

1. 分组异或
   - 先对所有数字进行一次异或，得到两个出现一次的数字的异或值
   - ==在异或结果中找到任意为 1 的位==，根据这一位对所有的数字进行分组（==&操作==）。
   - 在每个组内进行异或操作，得到两个数字。

### ×消失的两个数字

给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。 要求时间复杂度是O(n)，空间复杂度是O(1)。

1. 分组异或

   - 先对所有数字进行一次异或，再把1~N的数字也加入异或，得到两个出现一次的数字的异或值
   - 在异或结果中找到任意为 1 的位，根据这一位对所有的数字进行分组，==同时需要把1~N的分组加入==

   - 得到一个数组，与1得出的结果进行异或，得到两个数字

------

### ×形成两个异或相等数组的三元组数目

给你一个整数数组 arr 。

现需要从数组中取三个下标 i、j 和 k ，其中 (0 <= i < j <= k < arr.length) 。

a 和 b 定义如下：

a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]
注意：^ 表示 按位异或 操作。

请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。

1. O(n^2)

   ==a == b 可以推出 a ^ b == 0==，即找到异或为0的位置，从i 到 k

   ==固定了i和k，中间的j可以任意取，有k-i种==

### ×缺失的第一个正数

给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。时间O(n)，空间O(1)

思路：缺失的第一个正数，一定在[1, n+1]

1. Set

   遍历一遍，使用Set保存数组，然后遍历1-n，查看是出现过

2. 将数组视为哈希表

   ==由于[1, n+1]的特殊性，可以让数字对应数组下标==

   - 先将数组中负数排除干扰，将负数设为n+1
   - 将数字作为下标-1（数组索引从0开始，因此需要-1），将对应的地方添加一个负号（不会影响原来的数字）
   - 遍历数组，如果出现正数，则返回对应的下标+1，没有出现返回n+1

### 数组中重复的数字

在一个长度为 n 的数组 nums 里的所有数字都在 ==0～n-1 的范围==内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

1. Set

2. ==原地交换==

   由于数组的0~n-1，如果没有重复数字，那么正常排序后，==数字i应该在下标为i==的位置

   从头扫描数组，遇到下标为i的数字如果不是i的话，（假设为m),那么我们就拿与下标m的数字交换。在交换过程中，如果有重复的数字发生，那么终止返回ture

### ×数组中数字出现的次数 II

在一个数组 `nums` 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

思路：考虑数字的二进制形式，对于出现三次的数字，==各**二进制位**出现的次数都是 3 的倍数==

1. 遍历统计

   统计所有数字的各二进制位中 1 的出现次数（==不断右移，和1与运算==），把每位的次数余3，再通过==左移、或运算==将以数组形式存放的二进制转化为数字

### 和为s的两个数字

输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可

1. Map
2. 双指针

### 和为s的连续正数序列

输入一个正整数 target ，输出所有和为 target 的连续正整数序列

1. 暴力

   暴力列举1到(target-1)/2，从1开始加，超过target就退出

2. 暴力+数学优化

   暴力列举下界1到(target-1)/2，使用求和公式（n可以使用上界-下界+1表示出来）+求根公式，能直接解出上界

3. 双指针（滑动窗口）

   规定一个滑动窗口，left，right，重点是怎样移动？
   
   - sum < target，right++
   - sum > target，left++
   - sum == target，找到结果，==left++==

### ×把数组排成最小的数

输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个

思想：本质可转换为排序问题

==拼接字符串x，y==

- ==若拼接字符串 x + y > y + x ，则 x > y==
- ==反之，若 x + y < y + x，则 n < m==

1. 使用内置排序

   把int[]转为String[]，使用Arrays.sort()

2. 手写快排

### ×最大交换

给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值

1. 贪心

   先找到==第一个出现的上升位置==，如果没有上升，那么就直接返回数字

   - 在上升位置之后，==找最大位置==，越靠后越好
   - 在上升位置之前，==找最前的位置==，只要小于最大值，越靠前越好

### ×统计作战单位数

`n` 名士兵站成一排。每个士兵都有一个 **独一无二** 的评分 `rating` 。

每 **3** 个士兵可以组成一个作战单位，分组规则如下：

1. 暴力

   遍历中间的士兵，统计 **左边/右边** 比他 **小/大** 的士兵人数

   每个中间的士兵能组成的数量为：**左**边比他**小**的人数 × **右**边比他**大**的人数 + **左**边比他**大**的人数 × **右**边比他**小**的人数

### ×颜色分类

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

1. 计数排序

   两次遍历，先对0，1，2计数排序，然后直接修改数组上的数

2. 一次遍历（荷兰三色旗问题解 ）

   使用三个指针，left追踪0的最右边界，right追踪2的最左边界，curr表示当前元素

   - 若 nums[curr] = 0 ：交换第 curr个 和 第left个 元素，并将指针都向右移。
   - 若 nums[curr] = 2 ：交换第 curr个和第 right个元素，并将 right指针左移 。
   - 若 nums[curr] = 1 ：将指针curr右移。

### ×种花问题

花不能种在相邻的地方上，给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。

1. 贪心

   ==连续三个0就可以种花，以中间的那个作为判断，如果出现，就把中间的置为1==（下次再扫描就不会出现三个0了）

注：遇到最左边，最右边时要特判一下

### ×灯泡开关 III

房间中有 n 枚灯泡，编号从 1 到 n，自左向右排成一排。最初，所有的灯都是关着的。

在 k  时刻（ k 的取值范围是 0 到 n - 1），我们打开 light[k] 这个灯。

灯的颜色要想 变成蓝色 就必须同时满足下面两个条件：

灯处于打开状态。
排在它之前（左侧）的所有灯也都处于打开状态。
请返回能够让 所有开着的 灯都 变成蓝色 的时刻 数目 。

1. 暴力

   使用一个数组存储灯泡亮的位置，在循环遍历每一个位置之前的灯泡是否都是亮着的

 2. 动态规划

    ==记录最大亮起来的灯的位置，若打开灯的数量和最大亮起的位置相等==， 则说明之前的灯泡都亮了

### ×检查数组对是否可以被 k 整除

给你一个整数数组 arr 和一个整数 k ，其中数组长度是偶数，值为 n 。

现在需要把数组恰好分成 n / 2 对，以使每对数字的和都能够被 k 整除。

如果存在这样的分法，请返回 True ；否则，返回 False 。

1. 数组

   对数组对个数进行统计，==所有余数都将在0到k之间==。而k-i和i这两个数的个数，决定了这一对是否能k整除

   因此可以使用数组对个数进行统计，即counts[num % k]++，==但是由于数组中存在负数，Java中取模仍还是负数==

   ==因此可以给模之后的结果加上k，即 num % k + k，但此时如果是0，则结果为k，因此再给它余上k，方便求答案，即counts[(num % k + k) % k]++==

   最后判断i和k-i的个数是否相同，并额外判断nums[0]是否是偶数

2. Map

### ×旋转数组

给定一个数组，将数组中的元素向右移动 *k* 个位置，其中 *k* 是非负数

1. O(n)空间

   新建一个数组，将对应(i+k) % n的坐标置为nums[i]

2. 循环替换

   设置一个cnt计数，元素移动一次，cnt++，一共需要移动n次

   使用do-while循环，并使用prev保存前一个值

3. 翻转

   先将整个数组翻转一次，再翻转前k个数，再翻转后k个数

==注意：防止k超过数组大小，要先对k做取余操作==

## 排序

### ×数组的相对排序

给你两个数组，arr1 和 arr2，

- arr2 中的元素各不相同
- arr2 中的每个元素都出现在 arr1 中

对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。

1. 计数排序

   创建排序数组，遍历arr1，加入到排序数组中。遍历arr2，将arr2中出现的数字在排序数组中查找，按照次数覆盖到arr1

   因为还有未出现的数字，还需要遍历一遍排序数组

2. 自定义排序规则

   使用Map存储arr2，key为值，value为索引

   - 若比较的两个元素都在map中，则比较它们的索引
   - 若有其中的一个元素在map中，则在map中的元素比较小
   - 若两个元素都不在map中，则比较它们的值

## 堆

**升序...大量数据中最小的N个值...使用大顶堆**

**降序...大量数据中最大的N个值...使用小顶堆**

### ×最小的k个数

==找前 K 大/前 K 小问题不需要对整个数组进行 O(NlogN) 的排序==

1. 使用系统的排序

2. 自定义快排

   直接通过快排==切分排好第 K 小的数（下标为 K-1），那么它左边的数就是比它小的另外 K-1 个数==

   将每次排序的index索引返回

   - index大于k，就排序low~index
   - index小于k，就排序index~high

3. 小顶堆

   把数字全部压入小顶堆中，弹出队尾的元素直到剩下K个

4. 大顶堆

   维护K的容量

   - 当未超容量时，直接添加新的元素
   - 当超过容量时，弹出队尾，并加入新的元素

### 数组中的第K个最大元素

在未排序的数组中找到第 k 个最大的元素

1. 快排

   ==每次快排可以确定一个元素在数组中的位置==，这个位置和第k大元素的位置比较

   - 若等于，直接返回
   - 若在右边，递归查找左边
   - 若在左边，递归查找右边

2. 最大堆

   建立一个大根堆，做 k - 1次删除操作后堆顶元素就是我们要找的答案

### ✔✔前 K 个高频元素

给定一个非空的整数数组，返回其中出现频率前 **k** 高的元素。

1. 统计+排序

   使用Map统计每个数字出现的次数，按出现出现的次数进行排序

2. 小顶堆

   利用Lambda表达式给PriorityQueue传入map.get(key)，构造按次数排列的小顶堆

   ```java
   PriorityQueue<Integer> heap = new PriorityQueue<Integer>((a, b)->map.get(a) - count.get(b));
   ```

   将数组传入小顶堆中，如果堆中数量大于k，就把队首的元素去掉

### ✔前K个高频单词

给一非空的单词列表，返回前 *k* 个出现次数最多的单词。

返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。

1. 小顶堆

   先使用Map统计每个单词出现的次数，然后利用Lambda表达式给PriorityQueue传入map.get(key)

   出现次数相同时，调用compareTo比较字符串字典序

   将数组传入小顶堆中，如果堆中数量大于k，就把队首的元素去掉

   注：==最后返回list的时，不能调用ArrayList的构造函数（这时使用的copyOf直接复制），而 PriorityQueue的数组顺序不是它的堆顺序==

   要使用pq.poll()，弹出每一个元素加入到list中

### ✔最接近原点的 K 个点

我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。

（这里，平面上两点之间的距离是欧几里德距离。）

你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。

1. 大顶堆，O(nlogn)

   先将前K个点加入到大顶堆中，然后再加入时，判断堆顶和加入的大小，若小于堆顶就poll()，再添加

2. 快排，O(n)

   使用快排，==每次快排可以确定一个元素在数组中的位置==，若在快排的交换时候正好等于K，代表K之前已经排序完成

   - 若等于，直接返回
   - 若小于K，递归查找右边
   - 若大于K，递归查找左边

## 栈

### ×每日温度

请根据每日 气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 `0` 来代替

1. 暴力

   双重循环，遍历每一个位置，再对每一个位置向后搜索第一个比它大的

2. 单调栈

   维护一个单调栈（栈存储下标），遍历数组，==如果栈不为空且当前数字大于栈顶元素，那么取出栈顶元素==，由于当前数字大于栈顶元素的数字，而且一定是第一个大于栈顶元素的数，直接求出下标差就是二者的距离

### ×绝对差不超过限制的最长连续子数组

1. 单调栈

   维护两个单调栈（栈存储下标），一个维护当前窗口的最大值，一个维护最小值，保持最大值与最小值的差小于 limit

   当前窗口的最大值最小值的差大于 limit，则不断缩小窗口（左沿++），直至最大值变小或者最小值变大从而满足 limit 限制

## 双指针

### 二维数组中的查找

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

1. 双指针

   ==**从右上角开始**==，从左上角没法做！！

   - 如果当前元素大于目标值，则移到左边一列
   - 如果当前元素小于目标值，则移到下边一行

### ==供暖器==

给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。

1. 对于每个房屋，要么用前面的暖气，要么用后面的，二者取近的，得到距离；

   对于所有的房屋，选择最大的上述距离。

   先对房屋和供暖器进行排序。遍历每个房屋，设置一个供暖器的指针i，对于每一个房屋，若找到比i位置远，i+1位置近的热水器，就i++，每次保存最大的距离

### ×长按键入

你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。

你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。

1. 双指针

   name数组和typed数组各一个指针，如果两个数相同就都向后移动一格，如果不同，则移动typed数组的指针直到遇到新的字母。注意多种失败条件提前判断

------

### 合并排序的数组

给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。

1. 双指针

   尾插法，从后向前不会覆盖掉数据 

### 调整数组顺序使奇数位于偶数前面

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分

1. 前后指针

   低指针遇到第一个偶数，高指针遇到第一个奇数，两者进行交换

2. ==快慢指针==

   慢指针slow存放下一个奇数应该存放的位置，快指针fast往前搜索奇数，搜索到之后然后就和slow指向的值交换

### ×复写零

给你一个长度固定的整数数组 `arr`，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。请对输入的数组 **就地** 进行上述修改

1. 快慢指针+两次遍历

   首先先遍历一次，快慢指针移动，遇到0，快指针多移动一次（相当于统计要丢弃多少个元素）

   第二次遍历，从后向前，利用前两个指针，遇到0，快指针多向前移动一次

------

### 比较含退格的字符串

给定 `S` 和 `T` 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 `#` 代表退格字符。

1. 双指针

   从尾部开始，如果遍历到一个退格符，那么再往左第一个非退格字符将会被删除，剩余未被删除的字符就是最终的字符串。

2. 使用栈

   遇到#就弹出，否则就入栈，最后比较字符串是否相等

### 数组中的K-diff数对

给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k.

1. 排序+双指针

### 水果成篮

第 `i` 棵树产生 `tree[i]` 型的水果，可以从任何树开始。你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。你能收集的水果总量

1. 双指针+回溯

   通过两个指针start和end，来标识符合要求的区间，遇到第三种水果时，把指针向前移动到第二种水果不间断的刚开始位置

### ×单词距离

有个内含单词的超大文本文件，给定任意两个单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?

1. 遍历

   对单词列表进行遍历，==使用两个指针记录出现了查找单词的位置==，然后更新两个指针之间的距离

## 子数组

### ✔子数组最大平均数 I

给定 `n` 个整数，找出平均数最大且长度为 `k` 的连续子数组，并输出该最大平均数。

1. 滑动窗口

   窗口固定为k，维护一个窗口内的平均值，每次移动一格，减去最左边，加上最后边的，求最大值

2. 优化

   ==不需要维护平均值，维护和即可==

### 大小为 K 且平均值大于等于阈值的子数组数目

给你一个整数数组 `arr` 和两个整数 `k` 和 `threshold` 。请你返回长度为 `k` 且平均值大于等于 `threshold` 的子数组数目。

1. 双指针+滑动窗口

   先求出固定窗口之间的和，然后向右滑动窗口，求窗口之间的和时，减去上一个窗口的最左边，加上新进过来的，避免每次重新计算中间部分

### ×两个非重叠子数组的最大和

给出非负整数数组 `A` ，返回两个非重叠（连续）子数组中元素的最大和，子数组的长度分别为 `L` 和 `M`。（长为 L 的子数组可以出现在长为 M 的子数组之前或之后。）

1. 前缀和

   先存储数组的前缀和（可以叠加在原数组上），方便求数组之间的和

   要发现一个==关键点，L和M要么一个在前，要么另一个在前==，利用这点，遍历数组，每次比较L在前和M在前的

------

### ×区间子数组个数

给定一个元素都是正整数的数组`A` ，正整数 `L` 以及 `R` (`L <= R`)。求连续、非空且其中最大元素满足大于等于`L` 小于等于`R`的子数组个数

1. 计数

   连续子数组的个数 是按公差为1的等差数组 增长的

   ==区间大于等于L小于等于R的子数组个数 = 区间小于等于R的子数组个数 - 区间小于L的子数组个数==

   使用双指针分别统计小于等于R和小于L的子数组个数，它们的差值就是答案

### 子数组的最小值之和

给定一个整数数组 `A`，找到 `min(B)` 的总和，其中 `B` 的范围为 `A` 的每个（连续）子数组。

由于答案可能很大，因此**返回答案模 `10^9 + 7`**。

1. 动态规划（超内存）
   - `dp[i][j] `代表以i开头，j结尾的子数组的最小值
   - 当i == j时，`dp[i][j] = A[j]`
   - 其他，` dp[i][j] = Math.min(dp[i][j-1], A[j])`
   - 累加`dp[i][j] `，求得答案

2. 单调栈

   #TODO

### ×长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

1. 滑动窗口+双指针

   使用left，right表示子数组的开始位置和结束位置，维护变量 sum 存储子数组中的元素和，将right位置的数字加入sum中

   若sum>= s，则sum减去left位置的数字，并更新最小长度

### ×数组的度

给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。

你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。

1. Map

   - 使用三个Map分别记录，count出现的次数，first出现的第一个位置，last出现的最后一个位置

   - 遍历count求得最大值（==Collections.max(count.values())==）

   - 再次遍历count，当出现最大值时，更新last和first中记录的长度

2. 使用数组

   根据题目中数据条件小于49,999，创建三个数组代替Map

## 前缀和

### 和为K的子数组

给定一个整数数组和一个整数 **k，**你需要找到该数组中和为 **k** 的连续的子数组的个数。(存在负数)

1. 暴力

   双重循环，每次以不同的数作为子数组的新开头，逐渐求和，观察和是否等于k

2. ×前缀和 + 哈希表

   使用哈希表保存了之前相同前缀和的个数，计算区间总数的时候不是一个一个地加，将时间复杂度降到O(N)

   - 计算完成前缀和之后，计算当前数之前，有多少个前缀和等于 preSum - k，加入答案
   - 将当前的前缀和放入哈希表中维护，如果之前出现过，就+1，否则为1

### ×统计「优美子数组」

给你一个整数数组 nums 和一个整数 k。如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。

请返回这个数组中「优美子数组」的数目。

1. 双指针

   #TODO

2. 前缀和 + Map

   使用Map存储前缀和，key为当前奇数的个数，value是数组中元素的个数，每次都将当前的奇数个数放入Map中更新，数组长度变为原来的+1

   有k个奇数数字，就查看Map中sum - k的次数即可

3. 前缀和 + 数组

   考虑到奇数个数最大为数组长度，可以使用数组代替Map，==使用数组下标来表示奇数的个数==

### ×字母与数字

给定一个放有字符和数字的数组，找到最长的子数组，且包含的字符和数字的个数相同。返回该子数组，若存在多个最长子数组，返回左端点最小的。若不存在这样的数组，返回一个空数组。

1. 前缀和+Map

   使用Map存储前缀和，当数组中元素是字符时，前缀和+1，是数字时，前缀和-1，==当前缀和相等时，代表包含字符和数字的个数相同==

   使用left，right，len表示一个子数组，当新的子数组长度大于已有的时，更新left，right，len

### ×生存人数

见下面

## 交集 & 合并

### ✔两个数组的交集

给定两个数组，编写一个函数来计算它们的交集。输出结果中的每个元素一定是唯一的。

1. Set

   遍历第一个数组，添加到Set中，遍历第二个数组，遇到Set中包含的就remove掉，并添加答案

2. 双指针

   先排序，使用双指针，相等时候需要跳过重复

### 两个数组的交集 II

给定两个数组，编写一个函数来计算它们的交集。输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致

1. Map

   遍历第一个数组，使用Map保存数字为key，和出现的次数value

   遍历第二个数组，查看数组对应的value是否大0，并-1更新

2. 双指针

   先对两个数组进行排序，然后双指针查找

### ×==合并区间==

给出一个区间的集合，请合并所有重叠的区间。

1. 排序

   排序后使用当前区间和后一个区间进行比较，根据结果来进行合并或者开辟新的区间，==合并时右端点要取最大值==

优化点：

- 返回值是`int[][]`，直接申请最大位置，通过Arrays.copyOf()返回
- Arrays.sort()，通过Lambda表达式

### ==×生存人数==

给定N个人的出生年份和死亡年份，第`i`个人的出生年份为`birth[i]`，死亡年份为`death[i]`，实现一个方法以计算生存人数最多的年份。

1. 数组记录

   题目规定所有人都出生于1900年至2000年，可以使用数组102来记录出生和死亡时刻

   ==在根据数组来求前缀和（即生存人数），求最大值==

### ×变换数组

现在给出一个序列A，其中难免有些相同的元素，现在提供了一种变化方式，使得经过若干次操作后一定可以得到一个元素各不相同的序列。

这个操作是这样的，令x为序列中最小的有重复的数字，你需要删除序列左数第一个x，并把第二个x替换为2*x。

1. LinkedHashSet

   由于需要维护插入的顺序，使用LinkedHashSet

   ==当set中添加到重复元素时，把该元素删除掉，并递归添加2倍的该元素==

## 求最少操作次数

### ×使数组唯一的最小增量

给定整数数组 A，每次 *move* 操作将会选择任意 `A[i]`，并将其递增 `1`。返回使 `A` 中的每个值都是唯一的最少操作次数。

1. 排序

   先排序，后遍历数组，若当前元素小于等于它的前一个元素，则将其变为前一个数+1

## 矩阵

### ×螺旋矩阵

给定一个包含 *m* x *n* 个元素的矩阵（*m* 行, *n* 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

1. 可以模拟打印矩阵的路径

   开辟一个矩阵visited来保存已经遍历过的元素，**当矩阵到达边界或者已经遍历过的元素**，就顺时针旋转（类似BFS操作），具体如下操作：

   - ==定义矩阵移动的四个方向，使用dx、dy组合，通过%4来完成操作==

2. 按层模拟

   可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。

   定义四个变量，left，right，top，bottom，表示四个角的位置，遍历完当层之后更新四个变量，==循环终止条件为：left <= right && top <= bottom==

![](C:\Users\Administrator\Desktop\春招\总结\imgs\leetcode01.png)

### ××旋转矩阵

给你一幅由 `N × N` 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。（原地算法）

1. 原地旋转
   $$
   matrix[col][n−row−1]=matrix[row][col]
   $$
   根据第一行推出的规律，得到
   $$
   \left\{  
       \begin{array}{**lr**}
   	 row = col \\
   	 col = n−row−1
   	 \end{array}
   \right.
   $$
   带入推出的规律，得到
   $$
   matrix[n - row - 1][n - col - 1] = matrix[col][n−row−1]
   $$
   以此类推，可以得到，四个表达式，使用temp作为中间变量，就可以原地修改
   
   ==循环中，奇数行中间不需要旋转（在外层使用i < (n + 1) / 2， 在内层使用 j < n / 2）==

### ×矩阵按ZigZag打印

输入一个m*n的矩阵matrix，按照ZigZag方式打印矩阵的元素

1. 双指针

   定义两个指针，一个指针向右、向下移动，另一个向下、向右移动，==这两个指针的连线就代表了一个对角线==。再使用一个boolean标记打印的方向

### ×将矩阵按对角线排序

给你一个 `m * n` 的整数矩阵 `mat` ，请你将同一条对角线上的元素（从左上到右下）按升序排序后，返回排好序的矩阵

1. Map + List

   将横纵坐标之差作为key，List作为value添加到Map中，添加完成后对List进行排序，然后再遍历一边，在mat中进行修改

2. PriorityQueue

   遍历第一行与第一列，把对应对角线的元素添加到小根堆中，然后再把队列元素复制到数组中

### ×零矩阵

编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零

1. 额外空间

   开辟两个额外空间，用来标记找到0的坐标

2. 常数空间

   使用两个标记，标记第一行、第一列是否出现过0

   - 遍历数组将出现0的位置所在的第一行和第一列置0
   - 遍历第一列将出现0所在的行置0
   - 遍历第一行将所在的列置0
   - 检查两个标志位，将第一行、第一列置0

### ×图像重叠

给出两个图像 A 和 B ，A 和 B 为大小相同的二维正方形矩阵。（并且为二进制矩阵，只包含0和1）。

我们转换其中一个图像，向左，右，上，或下滑动任何数量的单位，并把它放在另一个图像的上面。之后，该转换的重叠是指两个图像都具有 1 的位置的数目。

（请注意，转换不包括向任何方向旋转。）

最大可能的重叠是什么？

1. 暴力，O（n^4）

   分别枚举每一个A，B中的1，计算出它们坐标的偏移量，放入计数器中。

   遍历计数器，求出最大的计数

### ×奇数值单元格的数目

给你一个 n 行 m 列的矩阵，最开始的时候，每个单元格中的值都是 0。

另有一个索引数组 indices，indices[i] = [ri, ci] 中的 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。

你需要将每对 [ri, ci] 指定的行和列上的所有单元格的值加 1。

请你在执行完所有 indices 指定的增量操作后，返回矩阵中 「奇数值单元格」 的数目。

1. 记录下标

   使用两个矩阵统计行和列的下标，由于只需要记录奇偶，可以使用boolean代替int，最后统计出行和列是奇数的个数，可以计算出一共有多少个单元是奇数，并减去它们相交的部分*2（行和列都贡献了1）