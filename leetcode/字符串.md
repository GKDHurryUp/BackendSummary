## 技巧

1. 双指针

2. 从后往前

3. 拼接长串

4. 消消乐原理

5. 滑动窗口

   **窗口的左边界和右边界永远只能向右移动**

6. 排序使得唯一

### 判定字符是否唯一

实现一个算法，确定一个字符串 `s` 的所有字符是否全都不同。

1. 字符数组

2. 位运算

   若字符都是小写字母，采用位数组的思想，==在一个int值的32位上进行编码==

   根据字符和'a'的距离，来对1进行位移

### ×字符串压缩

字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）

1. 双指针

   第一个指针指向开始，另一个指针向后移动，==使用两个指针做相等判断==

### ×计数二进制子串

给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

重复出现的子串要计算它们出现的次数。

1. 按字符分组

   我们可以将字符串ss 按照 00 和 11 的连续段分组，存在 counts 数组中，例如 s = 00111011，可以得到这样的counts 数组：counts={2,3,1,2}

2. 优化

   可以不使用数组存储，直接遍历过程中比较

### 字符串相加

给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和

1. 模拟十进制

   双指针，指向num1和num2的末尾，模拟十进制加法，定义一个进位变量
   
   ==循环条件是i >= 0 || j >= 0，如果其中有一个指针小于0，那么它贡献的值为0==
   
   最后进位为1，再添加一个

### 翻转字符串里的单词

给定一个字符串，逐个翻转字符串中的每个单词，如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个

1. 双指针

   - 倒序遍历字符串 s，记录单词左右索引边界 i , j；
   - 每确定一个单词的边界，则将其添加至单词列表 res

2. split

   遇到多个空格会==split成两个空数组==，在遍历的时候判断一下即可

3. 正则split

   使用regex正则表达式，`"\\s+"`分割多个空格

### 反转字符串中的单词 III

给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

1. 创建StrngBuilder

   使用split分开空格，添加到StrngBuilder中

2. 双指针翻转

   把String转换为char数组，使用两个指针定位到单词，再使用双指针对数组进行翻转



### 仅仅反转字母

给定一个字符串 `S`，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。

1. 双指针翻转

   遇到非字母符号就移动指针，否则就交换字母（可以使用异或，aba，右边一样）

### 字符串移位

给定两个字符串`s1`和`s2`，请编写代码检查`s2`是否为`s1`（移位）旋转而成

1. 拼接字符串

   把其中一个字符串，自己拼接自己，如s2+s2，看长的字符串是否包含s1

### 最常见的单词

给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。

1. Map+Set

   把禁用单词表放入Set中，遍历段落中每个单词，如果不出现在Set中，就把它加入Map中，同时更新最大单词的次数，以及对应的单词

   ==注：给原始paragraph后加一个'.'，可以防止额外的判断==

### 旅行终点站

给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。

题目数据保证线路图**不存在循环**的线路，因此只会有一个旅行终点站。

1. Map

   遍历paths，把所有的 cityAi 作为key，cityBi作为value放入Map中，只需要判断Map中是否有cityBi的key即可

### ×特殊等价字符串组

你将得到一个字符串数组 A。

一次移动包括选择两个索引 i 和 j，且 i ％ 2 == j ％ 2，交换 S[j] 和 S [i]。如果经过任意次数的移动，S == T，那么两个字符串 S 和 T 是特殊等价的。

现在规定，A 中的特殊等价字符串组是 A 的非空子集 S，这样不在 S 中的任何字符串与 S 中的任何字符串都不是特殊等价的。

返回 A 中特殊等价字符串组的数量。

核心：==找到公共表示方法==

1. 使用偶数索引和奇数索引分别排序

2. 统计偶数索引字母和奇数索引中的字母数量

   使用int[52]表示，这种排序，使用`Set<String>`保存，使用Arrays.toString将int[]转换为字符串放入Set中

优化：

使用`Set<Integer>`，==使用Arrays.hashCode将int[]转换为数字存入Set中==

### 解码字母到整数映射

给你一个字符串 s，它由数字（'0' - '9'）和 '#' 组成。我们希望按下述规则将 s 映射为一些小写英文字符：

1. 反向遍历

### 回文排列

给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。

1. 统计词频

   key为字符，value为次数，放入map中统计，最后统计出现奇数次数的数量

   - 偶数长度字符串，该数量要求为0
   - 奇数长度字符串，该数量要求为1

2. 方法一的优化

   题目没说是小写字母，那就不能使用int[26]，==而要使用int[128]==

3. 消消乐

维护一个Set，遇到重复的字符就remove掉

### 分割平衡字符串

在一个「平衡字符串」中，'L' 和 'R' 字符的数量是相同的。给出一个平衡字符串 `s`，请你将它分割成尽可能多的平衡字符串。

1. 贪心

   维护两个变量，分别代表L和R的字符数量

2. 方法一的优化

   **一个变量**即可，'L'出现的时候+1，'R'出现的时候-1==（消消乐思想）==

### 检查单词是否为句中其他单词的前缀

给你一个字符串 `sentence` 作为句子并指定检索词为 `searchWord` ，其中句子由若干用 **单个空格** 分隔的单词组成。

1. 贪心

   split分开`sentence` ，从前往后遍历，查看indexOf是否为0

2. ==拼接==

   给`searchWord` 前加一个空格

### ×第一个只出现一次的字符

在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 **s 只包含小写字母**。

1. HashMap

   遍历一遍，把字符加入到HashMap中，可以使用==Boolean代替Integer进行优化==

   在次遍历，按照数组的次序即可

2. LinkedHashMap

   遍历一遍，把字符加入到LinkedHashMap

   使用LinkedHashMap保持插入的顺序，遍历LinkedHashMa即可，就可以取出第一个只出现一次的字符

3. 使用数组代替HashMap

4. 使用indexOf和lastIndexOf

   直接对'a'~'z'遍历，找对应字符串中首尾第一个出现的

### 比较版本号

比较两个版本号 *version1* 和 *version2*。你可以假设版本字符串非空，并且只包含数字和 `.` 字符。

1. 双指针

   先使用split将字符串按'.'分割，==按两个长度最大来遍历，长度小的会越界，就给它填0==

### 变位词组

编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串

1. 排序+Map

   遍历字符串数组，==把对应的字符串进行排序放入Map中==，key为字符串，value为List列表

   如果存在就加入List，否重新创建一个List

   最后返回： ==new ArrayList<>(m.values())==

## 一、子串问题

###  数组中的字符串匹配

给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。

如果你可以删除 words[j] 最左侧和/或最右侧的若干字符得到 word[i] ，那么字符串 words[i] 就是 words[j] 的一个子字符串。

1. 暴力搜索

   ==对字符串数组按长度进行排序==，进行双重循环，从小到大判断长的字符串是否包含小的字符串

2. 拼接字符串

   ==把所有的字符串拼接成一个长的字符串==，根据第一次出现的位置，和最后一次出现的位置是不是同一个来判断

### 划分字母区间

字符串 `S` 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。

1. 贪心

   定义一个数组，==存储每个字母最后出现的位置==，对字符串进行遍历，==不断的更新最远边界==，当遍历到这个边界时，说明此段内的字母都是出现过的

### ××回文子串

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

1. 中心拓展

   枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。
   
   ==要计算奇数回文字符串(i, i)和偶数回文字符串(i, i+1)==

### 最长回文子串

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

1. 暴力 O(n^3)

   枚举所有的子串，判断是否为回文串，记录回文串的最长长度，进行剪枝

2. 中间拓展

   枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展

## 二、滑动窗口

### ==滑动窗口的最大值==

给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。

1. 暴力法思路：

   滑动窗口向右移动一位，

   - 若删除的不是最大值，取上一个的最大值和新加入的最大值
   - ==若删除的是最大值==，需要遍历整个窗口获取最大值

2. ==维护双端队列==，O(1)获取最大值（回想最小min栈）

   使用双端队列，==维护一个**非严格递减**的队列==

   遍历数组，

   - 若队列为空，则加入尾部
   - 否则，跟尾部值进行比较
     - 若小于尾部值，直接进入尾部
     - 若大于，则需要把队尾中删除到直至

### ×无重复字符的最长子串

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

1. 滑动窗口

   使用Map存储上一个重复字符的位置，定义left，right指针，遇到重复的字符，就把left置为重复字符的后一个位置（==left不能向左移==，取最大值），

2. 队列

   把字符添加到队列中，==如果有重复的，则让队列出队，直到无重复为止==

3. 使用Set

   用两个指针，代替队列，一个left一个right，如果有重复的就把left指向的给移除（left相当于队首，right相当于队尾）