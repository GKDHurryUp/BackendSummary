## 	动态规划 ##

1. 满足最优子结构
	大问题可以由小问题推出，求解思路一致
	
2. 满足无后效性
	一旦f(n)确定，不用关系它怎么计算
	
3. 设计好状态
	想办法把当前局面表达出来
	
4. 设计好状态转移方程
	我从哪里来，或者我到哪里去
	
5. 不会就扩大范围，暴力一点，找出使用之前计算过的值

   ==先使用暴力递归，把递归函数看成一个黑盒，假定它已经完成了我们的目标==

   如果暴力尝试时，可变参数超过了两个，并且单个类型超过了整数类型（变成数组），

### 除数博弈

最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：

选出任一 x，满足 0 < x < N 且 N % x == 0 。
用 N - x 替换黑板上的数字 N 。
如果玩家无法执行这些操作，就会输掉游戏。

方法一：
	归纳。拿到偶数获胜
方法二：
	动态规划，新建一个dp数组，dp[1] = false; dp[2] = true;根据dp之前的数据判断之后的数据


### ✔爬楼梯

1. 动态规划
   	`dp[i]=dp[i-1]+dp[i-2]` ，初始化dp[0] = 1, dp[1]  = 2;

### 买卖股票的最佳时机

状态穷举
看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。
每天都有三种「选择」：买入、卖出、无操作
`dp[i][k][0 or 1]`，0 <= i <= n-1, 1 <= k <= K，n 为天数，大 K 为最多交易数，0代表未持有股票，1代表持有股票
此问题共 n × K × 2 种状态，全部穷举就能搞定。

`dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])`
`dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])`

1.  ✔买卖股票的最佳时机	 	k=1

2. ✔买卖股票的最佳时机II	 	k=infinity
3. ×买卖股票的最佳时机III	 	k=2
4. ×买卖股票的最佳时机 IV   	k=K （要判断K和数组长度的关系，大于数组长度直接使用买卖股票Ⅱ）
5. ×最佳买卖股票时机含冷冻期	买（设置三个状态，相互装换）
6. ✔买卖股票的最佳时机含手续费	每笔操作需要减去手续费

------

### ✔打家劫舍、按摩师

选取数组中一些数组，使得最大，不可以连续取

1. 动态规划

   记录前两步的最大情况，当前的最佳情况=max(前两步最大+当前数组，前一步最大)

   注意边界，数组长度为1

### ×打家劫舍 II

选取数组中一些数组，围成一圈，使得最大，不可以连续取

1. 拆分+动态规划

   ==环状排列意味着第一个房子和最后一个房子中只能选择一个偷窃==，因此可以把此环状排列房间问题约化为两个单排排列房间

### ×打家劫舍 III

二叉树中，选取不连续的点，使得结果最大

1. 暴力递归

   递归返回的是能够盗取的最高金额，==它等于max（当前节点+左子树的左右子树+右子树的左右子树， 左子树+右子树）==

2. 记忆化递归

   使用Map存储节点对应的值，当节点有值时直接返回

### ×翻转数位

给定一个32位整数 num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度

1. 暴力

   遍历每一位，设置一个标记位，只能修改一次0，再统计最长长度（第二次循环从i开始，因为前面已经计算过了）

2. 动态规划
   - 使用两个数字记录，notChange表示不进行变动后的一串1的长度，change表示已经变换过的一串1的长度
   - 状态转移：
     - 若遇到1位，则两个数组都进行加1
     - 若遇到0位，change = notChange + 1，notChange = 0
   - 答案需要在循环中记录最大值

### 删除与获得点数

给定一个整数数组 nums ，你可以对它进行一些操作。每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。

开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数

- `nums`的长度最大为`20000`。
- 每个整数`nums[i]`的大小都在`[1, 10000]`范围内。

1. 动态规划

   ==此问题为打家劫舍的变体，由于每个数的大小都在`[1, 10000]`范围内，可以申请一个10001空间的数组，将数组存入新空间的下标中==，则转换为，不能取连续的两个数，求取到的最大值

------

### 使用最小花费爬楼梯

1. 动态规划

   第 i 级阶梯的总花费 = 第 i 级的cost + 前两级阶梯的总花费的较小者

   注意最后返回，上一级台阶或者是上两节台阶的最大值

### ✔三步问题

一次可以上1阶、2阶或3阶，结果模1000000007
注意：
	不能在返回时取余，==要在每步状态转移时计算时候取模==

### ✔区域和检索 - 数组不可变

多次求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和
方法：
	缓存思想，（积分图）
技巧：
	插入了一个虚拟 0 作为 sum 数组中的第一个元素。这个技巧可以避免在 sumrange 函数中进行额外的条件检查，注意边界

------

### ✔××完全平方数

给定正整数 *n*，找到若干个完全平方数（比如 `1, 4, 9, 16, ...`）使得它们的和等于 *n*，求组成和的完全平方数的个数最少

1. 动态规划

   - 储存完全平方数，square_nums[]

      - ==numSquares(n)=min(numSquares(n-k) + 1)==
        	预计算小于给定数字n的完全平方数列表

### ×比特位计数

计算0 ≤ i ≤ num 范围中的每个数字二进制数中的 1的数目

1. 动态规划
   使用==(i & (i-1)) == 0==来判断是否为1 2 4 8 16 等比数列。如果i是，则dp[i]=1,否则读取dp[i-最近的1 2 4 8数字] + 1
2. ​	P(x)=P(x/2)+(xmod2)
   ​	ans[i] = ans[i >> 1] + (i & 1); // x / 2 is x >> 1 and x % 2 is x & 1

------

### ✔××最长上升子序列

给定一个无序的整数数组，找到其中最长上升子序列的长度。

1. 动态规划
   	使用dp[i]代表以==第i个元素结尾==的==最大上升序列数量，跟前i个状态有关==
      	dp[i]=max(dp[j])+1,其中0≤j<i且num[j]<num[i]
   方法二：
   	贪心+二分查找。

------

### ✔×构建乘积数组

1. 构建dp数组

   本质就是两个dp数组，分别维护 i 左侧、右侧的乘积和

   左侧乘积从前往后开始，右侧乘积从后往前开始，注意不包含当前位置

### ×接雨水

给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

1. 暴力

   遍历，第二个至倒数第二个，求每一个位置的左右最大值，每次结果加上，左右最大值中小的那一个 - 当前位置的值

2. 构建dp数组

   方法一中每次都需要求最大值，==可以提前构建出左侧最大值数组，右侧最大值数组==

------

### ×××整数拆分 & 剪绳子

给定一个正整数 *n*，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

1. 暴力递归

   先从暴力开始，先要想清楚==F(n)返回的是什么==？==n拆分完成后返回的最大乘积==，想一想F(n-1)到F(n)是什么，它多了1，我们要把这个1分配到哪里？是多出来一个1还是把1并入之间的数字中？我们不知道，所以我们直接枚举这所有的情况：

   `1 * f(n - 1), 2 * f(n - 2), ..., (n - 1) * f(1)`

   再根据题意，求其中的最大值

   但如果`n - i`比`f(n - i)`要大，显然就不用再继续分解了。故我们还需要比较`i * (n - i)`与`i * f(n - i)`的大小关系。

   注意：2 <= n <= 58时可以使用，n大了以后有溢出，==当2 <= n <= 1000，这一题已经不能用动态规划了，取余之后max函数就不能用来比大小了（可以使用BigInteger）==

2. 数学

   > 尽可能将绳子以长度 3 等分为多段时，乘积最大。

   循环减3，答案每次乘3

### 最大整除子集 ###

给出一个由**无重复的**正整数组成的集合，找出其中最大的整除子集，子集中任意一对 (Si，Sj) 都要满足：Si % Sj = 0 或 Sj % Si = 0

描述：
1. 不表示所有子集，只记录长度
	设dp[i]为以第i个数字结尾的最大整除集合的长度。
推论一：可除以整除子集中的最大元素的任何值，加入到子集中，可以形成另一个整除子集

		if(nums[i] % nums[j] == 0)
			dp[i] = max(dp[j]) + 1;  // 0≤j<i
	
	没必要把每个集合都表示出来，记录最大的集合长度与它的索引即可，最后再遍历一次数组，把集合表示出来

2. 表示所有子集
	设dp[i]为以第i个数字结尾的最大整除集合。
		
		// 需要建立一个记得要初始化
		LinkedList<Integer>[] dp = new LinkedList[n];
   	 for(int i=0;i<n;i++){
			dp[i] = new LinkedList<>();
		}
	
	在求dp[i]的时候，核心还是求和最大集合个数的dp[j]，0≤j<i，最后返回集合个数最多的集合

### ×猜数字大小 II ###

1 到 n 之间选择一个数字。当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金，计算你至少需要拥有多少现金才能确保你能赢得这个游戏

- 思想：如果我们选择 i 作为第一次尝试，总体最小代价是：
	cost(1,n)=i+max(cost(1,i−1),cost(i+1,n))

1. 暴力
	递归求cost(1, n)，在left和right之间，每个数字都猜一遍
2. DP（自底向上）
	使用一个dp矩阵，其中dp(i, j) 代表在(i,j) 中最坏情况下最小开销的代价
3. 递归+记忆数组（自顶向下）
	在暴力递归的基础上，使用dp矩阵存储计算过的情况，如果计算直接返回结果，否则计算结果
	优化：在右边区间猜数即可，右边的区间开销肯定比左边高

### 多边形三角剖分的最低得分 ###



### ✔跳跃游戏

给定一个数组arr，数组中的每个元素代表在该位置可以跳跃的最大长度。求能否到达最后一个位置

1. 遍历数组，每次更新能到达的最远位置
   - 若到达不了下一个位置，返回false
   - 若能到达，更新最大位置

### ==跳跃游戏Ⅱ==

给定一个数组arr，数组中的每个元素代表在该位置可以跳跃的最大长度。求跳跃到数组末尾需要的最小的次数

1. 贪心算法

   遍历数组，每次更新能到达的最远位置maxPos，定义次数变量jump，和小于i能够走到的最远位置curr，如果i超过curr，就需要jump++，并且把curr更新为最远位置maxPos

### 跳跃游戏 III

这里有一个非负整数数组 arr，你最开始位于该数组的起始下标0 处。当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。

请你求出跳到下标为target处的最小步数，如果调不到返回-1。

1. 暴力递归

   使用dfs，暴力递归，每次传入dfs中有两个变化参数

------

### ×解码方法

一条包含字母 A-Z 的消息通过以下方式进行了编码：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

请计算长度为n的字符串解码方法的总数

思路：==从后向前==，当前位置的编码方式需要根据前面的步骤来计算

解码方法

1. 暴力递归

   第i个位置，和第i-1位置与第i-2位置有关

2. 递归+记忆化

   使用dp[]将答案记录下来，进来时候判定直接返回

   注：==要以-1为判定，如果答案可能为0，以0的话还会继续递归==

3. 动态规划

   总的状态方程为：`dp[i] = dp[i-1] + dp[i-2]`，但是要根据i位置是否为0，i-1位置和i构成的数字是否小于26来设条件

### 把数字翻译成字符串

给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

1. 暴力递归
2. 记忆化递归
3. 动态规划

​	与上一题只有一点不一样， 不需要考虑0

------

### n个骰子的点数

把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率

思路：求概率，==转换为求一个点数出现的次数==，再除以总次数就可以得到概率

1. 暴力递归

   n个骰子的点数分解为n-1个骰子的点数加上一个骰子的点数

2. 记忆化+递归

   穷举递归的变化条件，把它们使用二维数组存储下来，返回答案时记录下来，并在进来时候判定可以使用的话直接返回

   注：==要以-1为判定，如果答案可能为0，以0的话还会继续递归==

3. 动态规划

   **表示状态:` dp[i][j]`,表示投掷完 i枚骰子后，点数 j的出现次数**

   `dp[i][j]=dp[i-1][j-1]+dp[i-1][j-2]+dp[i-1][j-3]+dp[i-1][j-4]+dp[i-1][j-5]+dp[i-1][dp[j-6]`

4. 空间优化动态递归

   由于每个`dp[i][j]`只于i-1时刻的状态有关，所以可以删去一个维度，简化算法

   - 在上3解法的基础上，删去一个维度
   - 第二个循环从后往前遍历，**避免覆盖**
   - 每个阶段求值的时候，`先赋值 dp[j] = 0`

------

### 礼物的最大价值

在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物

1. 暴力DFS

   超时

2. 动态规划

   ==某单元格只可能从上边单元格或左边单元格到达==

   - 为矩阵第一行元素，只可从左边到达
   - 为矩阵第一列元素，只可从上边到达

### ✔最小路径和

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小

1. 动态规划

   - `dp[i][j]`表示以(i, j)位置结尾的路径最小和
   - `dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]`（可以直接在`grid[][]`上修改）
   - 初始化，第一行元素，只可从左边到达，第一列元素，只可从上边到达
   - 结果，右下角

2. 暴力递归

   起点(0, 0)，i，j==超过数组边界时返回Integer.MAX_VALUE==，==到达右下角返回数组中的值==

   返回`Math.min(dfs(grid, i+1, j), dfs(grid, i, j+1)) + grid[i][j]`

3. 记忆化+递归

   使用数组存储i, j的变化

------



### 零钱兑换

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

1. dfs

   排序硬币，先从最大的找，减去最大的，进行递归，==最先找到的并不是最==优解

   剪枝：

   1. ==可以使用乘法对加法进行加速==
   2. ==剪去比当前步数长的递归==

2. 记忆化dfs

   使用dp[]记录金额对应的硬币个数，如果递归中遇到就返回

3. 动态规划

   ==dp[i]为组成i所需要的最少硬币数量==，等于所有上一个金额所到达此金额的最小值+1

   `dp[i] = Math.min(dp[i], dp[(i - coins[j])] + 1)`

------

### 最大正方形

在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

1. 动态规划

   当我们判断以某个点为正方形右下角时最大的正方形时，那它的上方，左方和左上方三个点也一定是某个正方形的右下角

   ==`dp[i][j]`表示以i，j为右下角的最大正方形边长==，使用一个值求整个矩阵的最大值

   `dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1`

### ×最大的以 1 为边界的正方形

给你一个由若干 `0` 和 `1` 组成的二维网格 `grid`，请你找出边界全部由 `1`组成的最大 **正方形** 子网格，并返回该子网格中的元素数量。如果不存在，则返回 `0`

1. 动态规划

   以右下角来做判断，判断它上方和左方连续1的个数，根据他们中较小的一个

   - 含义，`dp[i][j][0] `代表以(i, j)位置往 左边 最长连续的1的个数

     `dp[i][j][1]`代表以(i, j)位置往 上边 最长连续的1的个数

   - 初始化，dp多申请一个空间，让dp的索引-1来找给出的二维矩阵
   - 左方等于前一个+1，上方等于前一个+1
   - 答案，定义maxLen，每一个求最大值

------

### ×三角形最小路径和

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。

1. 暴力递归

   递归参数，i，depth表示层数深度和位置，出口为层数深度大于长度，==由于三角形每层i回加1，所以i不会越界==

   返回 Math.min(dfs(i, depth+1), dfs(i+1, depth+1)) + triangle.get(depth).get(i)

2. 记忆化+递归

   使用`dp[][]`数组存储结果，穷举i和depth的变化

3. 动态规划
   - `dp[i][j]` 表示从点 (i, j)到底边的最小路径和
   - 初始化为0即可
   - `dp[i][j] = Math.min(dp[i+1][j], dp[i+1][j+1]) + triangle.get(i).get(j)` (dp空间多申请一个)
   - 答案`dp[0][0]`

### ×恢复空格

哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子"I reset the computer. It still didn’t boot!"已经变成了"iresetthecomputeritstilldidntboot"。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。

1. 动态规划，O(n)

   - 定义*dp*[*i*] 表示考虑前 i个字符最少的未识别的字符数量

   - 状态转移：每次转移的时候我们考虑第 j(j≤i) 个到第 i 个字符组成的子串 sentence[j−1⋯i−1]

     - 若能找到，dp[i] = min(dp[i], dp[j-1])

     - 若找不到，dp[i] = dp[i-1] + 1

   - 结果：dp[n]

2. 动态规划 + Trie树

   对于上述解法，计算 dp[i + 1]时，我们需要用 j来遍历前 i 个字符，逐个判断以j为开头，以第 i + 1 个字符为结尾的字符串是否在字典里。

   这一步可以利用字典树来加速，通过字典树我们可以查询以第 `i + 1` 个字符为结尾的单词有哪些（构建字典树时将单词逆序插入即可）。

   

## 序列

### 最长连续递增序列

给定一个未经排序的整数数组，找到最长且连续的**递增序列**，并返回该序列的长度。

1. 遍历

   查看后一个元素是否比前一个大，如果大就记录，否则置1

### 最长上升子序列

给定一个无序的整数数组nums[]，找到其中最长上升子序列的长度

1. 动态规划

   dp[i]代表，==以i结尾==的数组的==序列的最长长度==，如果i代表的元素最小，那么dp[i]=1，

   它和前i个状态都有关，如果nums[i] > nums[j]，0<=j < i，那么对nums[j]求最大值+1，就是dp[i]的值

   ==每个循环初始化dp[i] = 1==

2. 贪心+二分查找

   如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小

   维护一个数组 `d[i]` ，表示长度为 i 的最长上升子序列的末尾元素的最小值

   #TODO

### ×最长递增子序列的个数

给定一个未排序的整数数组，找到最长递增子序列的个数。

1. 动态规划

   - dp[i] 代表以i结尾的最长递增子序列的个数，counts[i] 为以nums[i]结尾的最长递增子序列的组合数量

   - 初始化，dp[] 为1，counts[]为1

   - 若`nums[i] > nums[j]`执行递增逻辑

     - 若`dp[j] + 1 > dp[i]`，则说明第一次找到以nums[i]为结尾的最长递增子序列

       counts[i] = counts[j]

     - 若`dp[j] + 1 == dp[i]`，则说明最新添加的nums[i]是多个序列公用的，需要叠加

       counts[i] += counts[j]

   - 求得最长的长度，当`dp[i] == maxLen`累加 `res += counter[i]`为答案

### 最大上升子序列和

1. 动态规划

   ==dp[i]代表以i结尾的数组的最大上升序列和==，如果i位置元素最小，那么dp[i]=nums[i]，它和比它小的状态有关，如果nums[i] > nums[j]，0<=j < i，那么对nums[j] + nums[i]求最大值

   ==每个循环初始化dp[i] = nums[i]==

### 最长定差子序列

给你一个整数数组 arr 和一个整数 difference，请你找出 arr 中所有相邻元素之间的差等于给定 difference 的等差子序列，并返回其中最长的等差子序列的长度。

1. 动态规划

   ==dp[i]代表 以数字i结尾的最长等差子序列的长度==，如果`nums[i] - nums[j] == difference，0<=j < i`那么对nums[j]求最大值+1

2. 动态规划优化

   ==使用Map存储，以数字i结尾的最长等差子序列的长度==，在查找时，直接查找`nums[i] - difference`

   或者根据数据界限，使用数组（全部加上difference的最大值），防止越界

### ✔✔××==最大子序和==

给定一个整数数组 `nums` ，找到一个具有最大和的**连续**子数组（子数组最少包含一个元素），返回其最大和

1. 动态规划
   从数组只有一个元素开始，每增加一个元素，思考，是从当前元素重新开始子序列，还是把当前元素加入到上一步的最优子序列。 

   ==dp[i]代表以i个数结尾的，连续的子数组最大和==，我们要求的是整个数组的最大自序和，因此要求它的最大值

2. 分治法

   连续子序列的最大和主要由这三部分子区间里元素的最大和得到

   - 子区间 `[left, mid]`
   - 子区间 `[mid + 1, right]`
   - 包含子区间 `[mid , mid + 1]` 的子区间（由于 `nums[mid]` 与 `nums[mid + 1]` 一定会被选取，可以从中间向两边扩散，**扩散到底**选出最大值）

   对它们三者求最大值即可

### ×连续的子数组和

给定一个包含 非负数 的数组和一个目标 整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，且总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数

1. 暴力

   三重循环，求数组中每一个连续子数组和，判断是否总和为k的倍数

2. 优化暴力

   提前存储前缀和，将三种循环改为双重循环

3. 使用Map

   使用 Map 来保存到第 i 个元素为止的累积和，但对这个前缀和除以 k取余数，只有Map中有相同的key就代表这两个索引之间的数组和是k的整数倍


### 最长连续序列

给定一个未排序的整数数组nums[]，找出最长连续序列的长度。

1. 排序

   遍历数组，记录最长的连续即可

2. 使用Map

   对数组进行去重，==只关注连续序列的头和尾==，每次使用Map更新头尾(通过取得前面和后面的长度)

3. 暴力DFS

   nums[]中的所有元素用set保存，对于每个元素nums[i]，都dfs的搜索==nums中比它小1的元素==，每搜索到一个，len+1。直到所有不到下一个为止，保存当前最大len为候选答案

4. DFS+记忆

   ==使用Map来保存遍历过的数字==，如果递归遇到了就直接返回

5. 并查集

   由于数字散布不确定，==只能使用HashMap映射根节点==，来写并查集结构，同时==使用HashMap保存节点代表的集合大小==，每次合并操作时更新指向的根节点，以及集合大小，同时数据结构中放置max，每次更新max

   ==查询时，查询数组时有没有比该数小一的元素==，有的话就将它们进行合并操作

### ×判断子序列

给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

1. 双指针

2. 动态规划（提前保存）

   预处理出对于 t 的每一个位置，从该位置开始往后每一个字符第一次出现的位置

   -  `dp[i][j] `表示字符串 t中从位置 i 开始往后字符 j 第一次出现的位置,  0 <= j < 26
   - 初始，`dp[m][j] = -1`,  0 <= j < 26
   - ==需要从后往前设置dp数组，防止覆盖==
     - 若如果 t中位置 i的字符就是 j，则`dp[i][j] = i `
     - 若不是，则`dp[i][j] = dp[i+1][j]`
   - 遍历字符串s
     - `若dp[idx][s.charAt(i) - 'a'] == -1`，则代表没有，返回false
     - 否则，更新idx到第一次出现该字符的位置的后一个

### ✔最长和谐子序列

和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。

1. Map，二次遍历

   把数组出现的次数计入Map中，==遍历Map==，查找key+1，存在的话，更新最大res

2. Map，一次遍历

   把数组出现的次数计入Map中，同时查看是否有key+1, key - 1的键，更新最大res

3. 排序+双指针

### ×最长重复子数组

给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

1. 动态规划
   - `dp[i][j] `代表，==A以第i个数结尾 和 B以第j个数结尾的最长子数组的长度==
   - 初始为0，`dp[i][j]`和对应的数组为i-1 , j -1
   - 当A[i-1] == B[j-1]时，`dp[i][j] = dp[i-1][j-1] + 1`
   - 答案需要使用maxLen来求最大值

------

### ×最长公共子序列LCS

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度

1. 暴力递归

   从后往前递归，递归出口为i或j小于0

   - 如果字符串当前位置相等，那么就找到一部分，返回 `dfs(i-1, j-1) + 1`
   - 若不相等，返回`max(dfs(i-1, j), dfs(i, j-1))`

2. 递归+记忆化

   ==注意到递归的变换参数其实就是指针i , j==，可以构造`dp[][]`数组来储存计算过的值，==注意要初始化为-1==

3. 动态规划

   `dp[i][j]代表text1 [0 ... i], text2[0 ... j]的最长公共子序列`

   - 若字符串当前位置相等，`dp[i][j] = dp[i-1][j-1] + 1`
   - 若不相等，`dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])`

   ==注意dp的指针与字符串的指针是不一致的，需要对齐==

### ×最长回文子序列

1. 暴力递归

   定义左右指针，递归进行验证，递归出口为`left >right ， left == right`分别返回0、1

   - 若左右指针位置相等，返回`dfs(c, left + 1, right-1) + 2;`
   - 若不等，返回`Math.max(dfs(c, left+1, right), dfs(c, left, right-1))`

2. 记忆化+递归

   ==注意到递归的变换参数其实就是指针left，right==，可以构造`dp[][]`数组来储存计算过的值，==注意要初始化为-1==

3. 动态规划

   四要素

   - `dp[i][j]` 表示从i位置开始，j位置结束的最长的回文子序列长度

   - 初始化，`f[i][i]=1`，单个字符的最长回文序列是 `1`

   - 转移方程`dp[i][j] = dp[i+ 1][j-1] + 2`

     `dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])`

     ==然后注意遍历顺序，`i` 从最后一个字符开始往前遍历，`j` 从 `i + 1` 开始往后遍历，这样可以保证每个子问题都已经算好了。==

   - 结果`dp[0][n-1]`

### ×交错字符串

给定三个字符串 *s1*, *s2*, *s3*, 验证 *s3* 是否是由 *s1* 和 *s2* 交错组成的

1. 动态规划
   - `dp[i][j] `代表s1中前i个元素，s2中前j个元素能否交错组成s2中前i+j个元素
   - 初始`dp[0][0] = true`
   - `dp[i][j]`取决于s1在i-1和s2在j-1的元素与s3的关系`dp[i][j] = (dp[i-1][j] and s1(i-1) == s3(i+j-1)) or (dp[i][j-1] and s1(j-1) == s3(i+j-1))`
   - 答案为`dp[len1][len2]`

### 栈的压入、弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。

1. 使用栈来模拟

   在遇到弹出的第一个元素前，按顺序把值压入栈中，遇到后弹出栈顶元素，指针移动到第二个弹出序列，如此重复，最后判断栈是否为空





## 背包问题

### ×硬币

给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)

1. 动态规划

   dp[i] 代表i有几种表示方法

   `dp[i] = d[i] + dp[i - coin] `

   第一层循环必须是遍历各种硬币，相当于我们每次只考虑前几种硬币的组合情况，硬币的排列会按遍历顺序添加；==如果先循环金额数，硬币的排列则是混乱的，导致出现重复情况==