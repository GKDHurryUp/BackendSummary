## Easy

### 十进制整数的反码

给你一个十进制数 `N`，请你返回其二进制表示的反码所对应的十进制整数。

1. 异或

   找到第一个大于等于该数的一个数，并且符合低位全为1，高位全为0
   
   使用求得的数与原数进行异或

### ✔==二进制中1的个数==

请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数

1. 31次循环

   通过mask不断左移，判断前31位，==最高位使用符号来判断==

2. n无符号右移

   n不断无符号右移，和1与

3. ==巧用 n \& (n - 1)==

   n &= (n -1)可以找到一个1

### ×不用加减乘除做加法

写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号

1. 位运算

   （a & b） << 1求进位，a ^ b求无进位和

   ==把求完的结果放入a和b中，才能继续迭代==

2. 递归

   省去定义中间变量
   
   - 返回条件：其中一个等于0，返回另一个
   - 递归中：一个为进位（a & b） << 1，一个为无进位和a ^ b

### ×字符串相乘（大数相乘）

给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式

1. 进位模拟

   ==相乘后的字符串要么就是m+n的空间，要么就是m+n-1==，因此先申请int[] nums数组，n+m的空间

   对于每个位置，相乘后的结果累加到nums中

   再遍历一边nums数组，将高位/10加到第一位，高位%10

   最后转换成字符串输出

### ××递归乘法

递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的A、B相乘。可以使用加号、减号、位移.

1. 模拟二进制乘法

   将A左移一位，B右移一位

   - 若B的最低位是1的话，那么就要加上A
   - 若B的最低位不是1的坏，那么相乘后就是0，不用相加
   - 递归出口：B为0，返回0，B为1返回A

### 回文数

给定一个整数x，判断x是否为回文数

1. 核心思想：翻转一半位置的数

   特殊情况：负数、最后一位为0、直接返回false

   模拟一个翻转的数reverse，每次获得x的低一位数，而x每次失去低位的一位数，当reverse>x时，翻转一半完成

   - x位数为奇数，x应该和reverse/10比较是否相等
   - x位数为偶数，x应该和reverse比较是否相等

### x 完美数

判断一个数是不是完美数，定义如下：

它和除了它自身以外的所有正因子之和相等

1. 枚举1-N，使用Set排除重复加入的数字，出现了重复的就推出循环
2. 实际上==只需要枚举1~sqrt(N)==

### 丑数

编写一个程序判断给定的数是否为丑数。（只包含质因数 `2, 3, 5` 的**正整数**）

1. 数学

   不断余5，3，2，最后判断是否为1即可

### ×丑数 II

编写一个程序，找出第 `n` 个丑数。

1. 三指针

   ==计算丑数序列也就是相当于 **合并 3 个有序序列**==

   三个有序序列，每个序列维护一个指针，比较它们的最小值，放在序列末尾

   ==如果最小值是当前指针贡献的，那么就右移一位==

### ×第 k 个数

有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21

1. 同丑数II

   ==先申请最大容量的数组，然后给数组填入内容，==填入最小的值

### 丑数 III

请你帮忙设计一个程序，用来找出第 n 个丑数（可以被 a 或 b 或 c 整除的 正整数）

#TODO

### ×数组中出现次数超过一半的数字（众数）

1. 统计每个数字的次数

2. 排序，中间的数

3. ==摩尔投票==（消消乐）

   维护一个投票箱

   - 如果出现相同的数字，就+1
   - 如果出现不同的数字-1

   ==当投票箱为0时，认为当前数字为答案==
   
   - 最后需要验证，是否出现超过一半

### ×求众数 II

给定一个大小为 *n* 的数组，找出其中所有出现超过 `⌊ n/3 ⌋` 次的元素。算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

1. Map

   Map统计每个数字出现的次数

2. ×摩尔投票法

   超过n/3的数最多只能有两个。先选出两个候选人A，B。 遍历数组，分三种情况：

   - 如果投A（当前元素等于A），则A的票数++;

   - 如果投B（当前元素等于B），B的票数++；
   - 如果A,B都不投（即当前与A，B都不相等）,那么检查此时A或B的票数是否减为0：

   遍历结束后选出了两个候选人，但是这两个候选人是否满足>n/3，==还需要再遍历一遍数组，找出两个候选人的具体票数==

### ×寻找两个正序数组的中位数

给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。

请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

1. 归并排序（O(m + n)）

   申请新数组，使用归并排序将两个数组排序到新数组中，然后根据数组的奇偶返回中位数

2. 二分查找

   

### ==×判断质数个数==

统计所有小于非负整数 *n* 的质数的数量。

1. 暴力枚举，==只需要枚举1~sqrt(N)==

2. 创立辅助数组大小为n，初始化true。**一个数字的倍数不可能为质数**，遍历到大于n为止，把数组内的值改为false

   优化：

   - 外层的 for 循环只需要遍历到 `sqrt(n)`
   -  内层循环 从 `i` 的平方开始遍历，而不是从 `2 * i` 

### ×和为 K 的最少斐波那契数字数目

给你数字 `k` ，请你返回和为 `k` 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。数据保证对于给定的 `k` ，一定能找到可行解。

- `1 <= k <= 10^9`

1. 贪心

   先生成小于10^9的斐波那契数组，==然后从后向前==，找到第一个比K大的数字，并减去，一直向前查找

### 罗马数字转整数

注：“ID”是非法情况，我不需要考虑

1. 将映射关系添加到HashMap中，如果字符串前一位比后一位小，直接减去前一位数

   如果大的话，加上前一位数。注意处理字符串的最后一位数

### 有效的回旋镖

判断三个点是否在一条直线上

1. 通过任意两点间的斜率判断，**注意除法会出现除0**，**将除法转换为乘法**

### x 的平方根

实现 `int sqrt(int x)` 函数。

1. 暴力，每一个都查找
2. 二分查找

### ××Pow(x, n)

实现 pow(x, n) ，即计算 x 的 n 次幂函数。

1. 暴力

   注意处理n小于0的情况

2. **快速幂+递归**

   ==计算x^n时，先计算x^⌊n/2⌋==，递归向下计算

### ×超级次方

你的任务是计算 *a**b* 对 1337 取模，*a* 是一个正整数，*b* 是一个非常大的正整数且会以数组形式给出



### 范围求和 II

将所有符合 **0 <= i < a** 以及 **0 <= j < b** 的元素 `M[i][j]` 的值都**增加 1**，返回矩阵中含有最大整数的元素个数

1. 暴力

   创建二维数组模拟

2. 求交集

   记录交集区域的右下角

### ×三个数的最大乘积

给定一个整型数组，在数组中找出由三个数组成的最大乘积，数组中存在负数

1. 定义五个数，最大max1，第二大max2，第三大max3，最小min1，第二小min2，最后返回
   $$
   max(max1*max2*max3,  max1*min1*min2)
   $$

### 平方数之和

给定一个非负整数 `c` ，你要判断是否存在两个整数 `a` 和 `b`，使得 a^2 + b^2 = c。

1. 枚举每一个小于c的平方数，判断是否存在一个数，使得等式成立
2. **双指针**，低指针从0开始，高指针从小于c的最大平方数开始，两端向中间移动

### 一年中的第几天

给你一个按 `YYYY-MM-DD` 格式表示日期的字符串 `date`，请你计算并返回该日期是当年的第几天。

1. 前缀和

   闰年：

   - 能整除4且不能整除100 
   - 能整除400 

### 三角形的最大周长

给定由一些正数（代表长度）组成的数组 `A`，返回由其中三个长度组成的、**面积不为零**的三角形的最大周长。

1. 排序数组

   **设三角形边长*a*≤*b*≤*c*，只需要满足a + b > c即可成为三角形**

   遍历数组，**选择尽可能大的边长**，如果最二长的边与第三长的边不满足a + b > c，数组剩下的元素也不会满足了。所以要往小方向移动一步，继续比较。

### 最大三角形面积

给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。

1. 穷举

   遍历每个点*O*(*N*3)，使用**鞋带公式**计算三角形面积

### ==卡牌分组==

你需要选定一个数字 `X`，使我们可以将整副牌按下述规则分成 1 组或更多组：

- 每组都有 `X` 张牌。
- 组内所有的牌上都写着相同的整数。

1. Map

   使用Map求出每张牌出现的次数，遍历次数，求两个数之间的最大公约数

### ×三维形体的表面积 

在N*N网格上，放置一些 `1 * 1 * 1 ` 的立方体。求出最终形体的表面积

1. 分步累加

   单独计算一格立方柱的贡献的表面积，再把所有的加起来

   - 顶面和底面，共享2

   - 四个侧面，贡献本立方柱与四个侧面的差值

     ```java
     int[] dx = new int[]{0, 1, 0, -1};
     
     int[] dy = new int[]{1, 0, -1, 0};
     ```

### 三维形体投影面积

在 `N * N` 的网格中，放置一些与 x，y，z 三轴对齐的 `1 * 1 * 1` 立方体。求出这些立方体在 xy、yz 和 zx 平面上的投影。

1. yz，zx投影面内求立方体高度的最大值

   xy投影面求是否存在立方体

### 将整数转换为两个无零整数的和

1. 枚举

   初始设为a = 1和 b= n-1两个数，如果a,b中有一个数存在0那么a++, b--

### 玩筹码

**每个筹码的位置**存在数组 `chips` 当中

你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）：

- 将第 i 个筹码向左或者右移动 2 个单位，代价为 0。
- 将第 i 个筹码向左或者右移动 1 个单位，代价为 1。

返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价

1. 遍历数组求奇数位置的个数和偶数位置的个数

### Excel表列名称

给定一个正整数，返回它在 Excel 表中相对应的列名称。（10进制到16进制转换）

1. 对26取余，针对0的情况做特殊处理

### ==制造随机函数==

给定一个随机函数得到a-b之间的数，求c-d之间的随机函数

1. 先将a-b直接的数表示为0，1，如果是奇数个节点，并且roll到中间的数再重新roll一次，左边的为0，右边的为1
2. 将c~d表示为0~(d-c)，看看有多少个数字，使用2进制进行编码，超过了目标数字的范围的话重新roll

### ==制造随机函数Ⅱ==

给你一个随机函数，以p的概率生成0，1-p的概率生成1，生成一个等概率随机函数

1. roll两次，00和11重roll，01和10概率相等

### 最小差值 I

给你一个整数数组 `A`，对于每个整数 `A[i]`，我们可以选择处于区间 `[-K, K]` 中的任意数 `x` ，将 `x` 与 `A[i]` 相加，结果存入 `A[i]` 。

在此过程之后，我们得到一些数组 `B`。

返回 `B` 的最大值和 `B` 的最小值之间可能存在的最小差值。

1. 求A的最小值min与最大值max，比较min+K和max-K的大小

### 最小差值 II

给定一个整数数组 A，对于每个整数 A[i]，我们可以选择 x = -K 或是 x = K，并将 x 加到 A[i] 中。

在此过程之后，我们得到一些数组 B。

返回 B 的最大值和 B 的最小值之间可能存在的最小差值。

1. 排序，较小的 `A[i]` 将增加，较大的 `A[i]` 将变小

### 最大数值

编写一个方法，找出两个数字`a`和`b`中最大的那一个。不得使用if-else或其他比较运算符。

1. 使用位运算，a-b求出最高位符号位，需要考虑整数溢出

### ×扑克牌中的顺子

从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。

1. 排序

   排序后按照王的个数逐个判断

2. 找最小值和最大值

   使用boolean数组(Set)去重，（==有重复就不能有顺子==）==跳过大小王==，记录最大值和最小值，判断它们的差值是否比5小，

### 错误的集合

集合 `S` 包含从1到 `n` 的整数。错误集合丢失了一个整数并且有一个元素重复。首先寻找到重复出现的整数，再找到丢失的整数。

1. Map找到重复元素，使用求和公式得到总和 减去 数组求和，再加上重复元素就是丢失的数
2. 使用数组记录重复元素，遍历两次

### 二进制间距

一个正整数 `N`，求二进制连续1之间的最大间距

1. 求二进制中的位数==(N>>i) & 1==，记录连续1的索引

### 强整数

给定两个正整数 `x` 和 `y`，如果某一整数等于 `x^i + y^j`，其中整数 `i >= 0` 且 `j >= 0`，那么我们认为该整数是一个*强整数*。

返回值小于或等于 `bound` 的所有*强整数*组成的列表。

1. 求得i，j的上届，注意有重复值，使用Set来存储

   ```java
   int maxI = x == 1? 0:(int)(Math.log(bound) / Math.log(x));
   int maxJ = y == 1? 0:(int)(Math.log(bound) / Math.log(y));
   ```

### 给定数字能组成的最大时间

给定一个由 4 位数字组成的数组，返回可以设置的符合 24 小时制的最大时间。

1. 穷举出每一种情况，做一个全排列，检查是否符合时间格式，转换为分钟数来求最大时间

### 分糖果 II

一些糖果 `candies`，分给n个小朋友，给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 `n` 颗糖果。

然后，我们再回到队伍的起点，给第一个小朋友 `n + 1` 颗糖果，第二个小朋友 `n + 2` 颗，依此类推，直到给最后一个小朋友 `2 * n` 颗糖果。

返回一个长度为 `num_people`、元素之和为 `candies` 的数组，以表示糖果的最终分发情况

1. 利用等差数列求和，求得发糖果的轮数，一次性发放完整的轮数，再把剩余的糖果挨个分发

### 二叉树寻路 ###

在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。
在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；
在偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。

1. 把顺序排列的二叉树写出来，可以发现label/2的结果按照**之行排列**的计算结果是**顺序排列**的**对称点**
	如果能用**n(所在的行数)求得这两个对称的和**，就可以解得此题了
	X=(Left+Right)−Label/2=3∗(2^n−1)−1−Label/2

2. 位运算
	先右移一位（就是/2）
	除第一位之外，按位取反



## 位运算

### 配对交换

配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。

1. 位运算

   生成一个mask，01010101010101的二进制，用来取得奇数位和偶数位

   交换奇偶位即为，偶数位左移1，奇数位右移1，对两者取或运算

### 替换

给定两个32位的整数N与M，以及表示比特位置的i与j。编写一种方法，将M替换N，使得M从N的第j位开始，到第i位结束。假定从j位到i位足以容纳M，也即若M = 10 011，那么j和i之间至少可容纳5个位。例如，不可能出现j = 3和i = 2的情况，因为第3位和第2位之间放不下M。

1. 位运算

   首先生成mask，从i到j都是0，其余都是1，==可以先求得位数+1，让1左移相应的位数得到的结果-1，然后在把结果左移i位就得到了mask==

   然后使用mask将N的i到j置0，再把M左移i位，替换到N上

## 排列组合

### 质数排列

从 `1` 到 `n`， 使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上，返回可能的方案总数 mod `10^9 + 7`。

1. 求出1~n的质数个数，返回质数的阶乘和合适的阶乘的乘积。

注：处理数据溢出的问题

### 旋转数字

 如果X的每位数字逐个地被旋转 180 度后，仍可以得到一个有效的，且和 X 不同的数，则X称为好数。要求每位数字都要被旋转。

2, 5,可以互相旋转为对方，6, 9同理，0，1，8旋转后不变，3，4，7旋转后为无效数字

1. 暴力

   从1列举到N，判断每个数字是否为好数。要求每位都在(2, 5, 6, 9, 0, 1, 8)内，至少一位在(2, 5, 6, 9)内，==使用递归判断最后一位，设置一个标记位，如果出现了(2, 5, 6, 9)把标记设为true，否则标记位不变==

### ×字符串的排列

输入一个字符串，打印出该字符串中字符的所有排列。

 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

1. DFS

   使用DFS， 每次固定第一个字母，后面字母和固定的字母互换，使用Set保存结果进行去重

2. DFS+剪枝

   使用DFS，每次固定一个字母，后面字母两两交换，进行剪枝

### ×下一个排列

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

1. 一边扫描

   - 从右边找到第一个递减的数字
   - 然后从这个递减数字之后，找到一个第一个比它大的数

   - 交换两数
   - 翻转第一个递减之后的数字

### ×不同的二叉搜索树

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

见【动态规划】



## 玩游戏

###  井字游戏

设计一个算法，判断玩家是否赢了井字游戏。输入是一个 N x N 的数组棋盘，由字符" "，"X"和"O"组成，其中字符" "代表一个空位

如果游戏存在获胜者，就返回该游戏的获胜者使用的字符（"X"或"O"）；如果游戏以平局结束，则返回 "Draw"；如果仍会有行动（游戏未结束），则返回 "Pending"

1. 遍历求和

   在一次遍历中可以对行、对列、对主副对角线进行求和，判断每一个行、列总和是否等于全是'X'或全是'O'的总和，最后再判断主副对角线是否等于全是'X'或全是'O'的总和

