### ✔✔×==用两个栈实现队列==

用两个栈实现一个队列，请实现它的两个函数 `appendTail` 和 `deleteHead` ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。

1. 先弄清楚，==栈底是队头，栈顶是队尾==

   - 第一个栈负责==添加元素==，它添加的顺序就是往队尾插入元素

   - 第二个栈负责==删除元素==

     - 如果它为空，就把第一个栈的**所有元素**弹出，全部放入第二个栈中（如果第一个栈没有元素，返回-1）

     第二个栈的栈顶就是队头，删除第二个栈的栈顶即可

### ×用队列实现栈

使用队列实现栈

1. 一个队列

   在push时，把队头的元素出队，重新添加到队尾，直到剩余一个元素在队头

   peek和pop时，队头的元素就是栈顶元素

### ==✔✔LRU缓存==

设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。

思路：

- get
  - 如果取不到key，返回-1
  - 如果取到key，把链表中的对应节点删除，并在链表尾部添加，返回对应val
- put
  - 若果能取到key，删除取到的节点，并在链表尾部添加
  - 若果取不到key
    - 超出容量，删除链表头部，删除Map（使用头部的key），添加链表尾部，添加Map（代码复用要size--）
    - 不超出容量，添加链表尾部，添加Map，size++

1. 使用LinkedHashMap

2. 使用HashMap + LinkedList

3. 使用HashMap + 自定义ListNode

   初始化head和tail，==固定head和tail，避免空指针==

   ```java
   static class ListNode {
       int key;
       int val;
       ListNode pre;
       ListNode next;
       public ListNode() {}
       public ListNode(int key, int val) {
           this.key = key;
           this.val = val;
       }
   }
   ```

### ✔×包含min函数的栈

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)

1. 自定义链表

   在链表中加入最小值，使用==头插法模拟栈==，每次插入的时候都维护最小值

2. 双栈

   第一个栈实现正常逻辑，第二个栈存储第一个栈中非严格递减的元素

   - push时，若stack2为空，或者stack2栈顶元素小于等于该值，则往stack2中添加
   - pop时，若删除的时最小值，则需要弹出stack2栈顶
   
   ==注：==×==判断栈顶元素是否相等时使用equals，不能使用等号==

### 三合一

描述如何只用一个数组来实现三个栈。

你应该实现push(stackNum, value)、pop(stackNum)、isEmpty(stackNum)、peek(stackNum)方法。stackNum表示栈下标，value表示压入的值。

构造函数会传入一个stackSize参数，代表每个栈的大小。

当栈为空时`pop, peek`返回-1，当栈满时`push`不压入元素。

1. 数组分段

   将数组分为三段，每段代表一个栈，==同时维护每个栈的大小==，通过计算每个栈的起始坐标，加上他们的大小的偏移量来进行出栈入栈

### 栈排序

编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中

1. 双栈

   第二个栈用作Buffer，第一个栈维护完整的数据

   push的元素大于栈顶元素，就把小于push的元素弹出到buffer中，在把添加的元素以及buffer中的元素添加回来

2. 双栈+惰性更新

   #TODO

### 包含最大值的队列

请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)

1. 双队列

   一个队列实现添加和删除的正常功能，另一个双端队列维护一个非严格递减队列，让最大的元素在队头。
   
   在每次入队时
   
   - 如果 deque队尾元素小于即将入队的元素 value，==则将小于 value 的元素全部出队后==（因为队列删除的时候时删除队头），再将value 入队；
   - 否则直接入队

### ×数据流中的第K大元素

设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。

1. 小顶堆

   ==保存小顶堆中只有K个元素==，堆顶就是最小的元素，每次添加时候比堆顶大，就移除堆顶再添加（==包括初始化阶段==）

### ×数据流中的中位数

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

思路：给定一长度为 N 的无序数组，其中位数的计算方法：首先对数组执行排序（使用O(NlogN) 时间），然后返回中间元素即可（使用 O(1) 时间），==因此并在添加元素时 **保持数组有序**==

1. 使用数组

   查找插入位置*O*(log*N*)，填入元素O(N)

2. 使用大小顶堆
   - 小顶堆A， 保存 **较大**的一半
   - 大顶堆B，保存 **较小** 的一半

算法：

设元素总数为 N = m + n，其中 m 和 n分别为 A 和 B中的元素个数。

- m == n，N为偶数，将新元素 num插入至 B ，再将 B 堆顶元素插入至 A 
- m != n，N为奇数，将新元素 num 插入至 A ，再将 A 堆顶元素插入至 B

### ×设计跳表

跳表是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。

1. 查找

   先往右再往下，缩小区间

### ✔×实现 Trie (前缀树)

实现一个 Trie (前缀树)，包含 `insert`, `search`, 和 `startsWith` 这三个操作

1. 数组

   ```java
   static class TrieNode {
   
       private TrieNode[] childrens;
       private boolean isEnd;
   
       public TrieNode() {
       childrens = new TrieNode[26];
   	}	
   }
   ```

   因为存在前缀搜索，isEnd是用来专门保存一个word的末尾信息

   - 维护一个root节点

   - 插入时，从root向下搜索，遇到为null，就新建一个放进去，最后把isEnd设置为true
   - 搜索时，从root向下搜索
     - 遇到null直接返回
     - 不为null，根据是全单词搜索还是前缀搜索，判断isEnd标志位

### ×单词频率

设计一个方法，找出任意指定单词在一本书中的出现频率。

你的实现应该支持如下操作：

WordsFrequency(book)构造函数，参数为字符串数组构成的一本书
get(word)查询指定单词在书中出现的频率

1. Map

2. Trie树

   在TrieNode中添加cnt成员变量，来记录单词出现的次数，在查询时，若遇到null，则返回0，返回对应单词出现的次数