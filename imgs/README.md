## 【七大原则】 ##
1.单一职责
	1)降低类复杂度，一个类只负责一个事情
	2)提高类的可读性、可维护性	
	3)降低变更引起的风险
	4)类足够简单时，可违反，在方法级别上保持单一职责
2.接口隔离
	一个类对另一个类的依赖应该建立在最小的接口上
3.依赖倒转（Dependence Inversion Principe）
	面向接口编程，使用接口或抽象类制定好规范
	依赖关系传递的三种方式：
		1)接口
		2)构造方法
		3)setter
4.里氏替换
	子类重写父类方法使得继承体系复用性变差，可以让父类和子类继承一个更通俗的基类，原有的继承使用依赖、聚合、组合等关系代替。
5.开闭 Open Closed Principle
	对拓展开放（提供方），修改关闭（使用方）。用抽象构建框架，实现扩展细节
6.迪米特法则 Demeter Principle（最少知道原则）
	一个对象应该对其他对象保持最少的了解
	只与直接的朋友通信（成员变量，方法参数，返回值），局部变量不是直接朋友
7.合成复用
	尽量使用合成/聚合的方式，而不是使用继承

## 【设计原则核心思想】 ##
1.找出应用中需要变化的地方，独立出来
2.面向接口编程
3.为了对象之间的松耦合设计而努力

## 【设计模式目的】 ##
1.代码重用性
2.可读性
3.扩展性
4.可靠性
5.使程序呈现高内聚，低耦合

## 【UML】 Unified Modeling Language 统一建模语言 ##
	用于软件系统分析和设计的语言工具，帮助软件开发人员进行思考和记录思路
	1.用例图
	2.静态结构图：类图（核心）、对象图、包图、组件图、部署图
	3.动态行为图：交互图（时序图与协作图）、状态图、活动图

## 【UML类图】 ##
类之间的关系：
	依赖、泛化（继承）、实现、关联、聚合、组合
依赖：
	只要使用了对方，就存在依赖关系
泛化：
	泛化关系实际上就是继承关系，是依赖关系的特例
实现：
	实现关系实际上就是A类实现B接口，是依赖关系的特例
关联：
	类与类之间的联系，是依赖关系的特例
	导航性，双向或单向关系
	多重性，一对一，多对多
聚合：
	表示整体和部分，整体与部分可以分开，是关联关系的特例
组合：
	表示整体和部分，整体与部分不可以分开（如级联删除）

## 【设计模式类型】3大类，23种 ##
1.创建型：单例、工厂、原型
2.结构型：装饰、代理
3.行为型：观察者、责任链

## 【单例模式】 ##
举例：
	Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session对象。SessionFactory是重量级的，通常一个项目只需要一个SessionFactory就够，使用到单例模式

### 1.饿汉式（静态常量） ###

步骤：
	1) 构造器私有化 (防止 new )
	2) 类的内部创建对象
	3) 向外暴露一个静态的公共方法
优点：
	写法简单，类装载（导致类装载的原因有多种）就实例化，避免线程同步问题
缺点：
	没有达到Lazy loading效果，如果没有使用过这个实例，会造成浪费

### 2.饿汉式（静态代码块） ###
	跟上面一样，也是在类装载的时候执行静态代码块中的代码

### 3.懒汉式（线程不安全） ###
优点：
	起到Lazy Loading效果
缺点：
	只能在单线程中使用，多线程情况下会产生多个实例

### 4.懒汉式（线程安全，同步方法） ###
	在方法上加入synchronized关键字
优点：
	线程安全
缺点：
	其它试图进入该方法的线程都必须阻塞等待，效率低下

### 5.懒汉式（线程不安全，同步代码块） ###
在new处加入同步代码块，但不解决问题，只要进入到if(instance == null)中，还是会创建一个新的
对象

### 6.懒汉式（双重检查） ###
优点：
	进行两次if(instance == null)检测，保证线程安全，延迟加载，效率较高

### 7.静态内部类 ###
静态内部类特点：
	1.外部类加载时，静态内部类不加载
	2.调用到静态内部类时，会加载静态内部类，并且线程安全
优点:
	使用类装载机制保证初始化实例只有一个线程
8.枚举
优点：
	保证线程安全，同时防止反序列化重新创建新的对象
缺点：
	不能懒加载
	反编译后为public final class T extends Enum

例子：
	JDK中，java.lang.Runtime，饿汉式
使用场景：
	1.频繁创建和销毁的对象
	2.重量级对象（创建对象耗时过多或消耗资源过多），如工具类对象、频繁访问数据库或文件的对象（数据源、session工厂）

## 【工厂模式】 ##
### 1.简单工厂模式 ###
介绍：
	1.由一个工厂对象决定创建出哪一种产品类的实例
	2.定义一个创建对象的类，由这个类封装实例化对象的行为
	3.软件开发中，使用工厂模式大批量创建某种、某类对象

### 2.工厂方法模式 ###
介绍：
	定义一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到了子类

### 3.抽象工厂模式 ###
介绍：
	1.定义一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体类

例子：
	JDK中Calendar类，使用了简单工厂模式，getInstance中使用了createCalendar方法，会根据传入的Timezone与Locale判断有没有此类型的CalendarProvider，若有直接返回，若没有则进行默认初始化，此时根据Local的值创建不同的地方的Calendar，如BuddhistCalendar、JapaneseImperialCalendar、GregorianCalendar

意义：
	将实例化对象的代码提取出来，放到一个类中统一管理维护，到达客户端解耦的目的，从而提高项目扩展和维护性

## 【原型模式】Prototype ##
介绍：
	1.创建新的对比较复杂时，可以使用原型模式简化对象的创建，同时提高效率
	2.不需要重新初始化对象
	3.原始对象发生变化，其它克隆对象也会相应变化不需要更改
	4.对象.clone(),浅拷贝，得到的对象内部的引用对象和原对象内部的引用对象地址相等。深克隆的时候需要比较复杂的代码

缺点：
	每个类都需要配备一个clone()方法，对已有类改造时，违背ocp原则
例子：
	Spring中原型bean的创建

深拷贝方法：
	1.重写clone()
	2.序列化与反序列化

## 【建造者模式】 ##
介绍：
	1.又称生成器模式，是一种对象构建模式。将复杂对象的建造过程抽象出来，使这个抽象过程的不同实现方法可以构造出不同属性的对象
	2.一步一步创建一个复杂对象，允许用户只通过指定复杂对象的类型和内容就可以构建，不需要知道细节

四个角色：
	1.Product 产品角色，具体的产品对象
	2.Builder 抽象建造者，创建Product对象的各个部件指定的接口/抽象类
	3.ConcreteBuilder 具体建造者，实现接口，构建和装配各个部件
	4.Director 指挥者，构建一个使用Builder接口的对象。
		1)隔离客户与对象的生产过程
		2)负责控制产品对象的生产过程

例子：
	JDK中，StringBuilder使用到了建造者模式，它继承了AbstractStringBuilder，AbstractStringBuilder实现了Appendable接口 ，	Appendable接口定义了多个append方法，Appendable为抽象建造者。
	AbstractStringBuilder为建造者
	StringBuilder即充当了指挥者角色，同时充当了具体的建造者

## 【适配器模式】 Adapter，又称包装器Wrapper ##
介绍：
	
1. 将某个类的接口转换成客户端期望的另一个接口表示，提高兼容性
2. 分为三类
	- 类适配器模式
	- 对象适配器模式
	- 接口适配器模式 


----------


1. 类适配器  
	Adapter类，继承src类，实现dst类接口，完成src->dst的适配
2. 对象适配器模式  
	Adapter类不是继承src类，而是持有src类的实例
3. 接口适配器模式 Default Adapter Pattern（缺省适配器模式）  
介绍：  
	1.不需要全部实现接口提供的方法，设计一个抽象类实现接口，并为每个方法提供空实现，子类可以有选择覆盖（	JDK8有接口可以默认空实现）  
例子：  
	SpringMVC中的HandlerAdapter，通过HandlerMapping来映射处理器（即Controller），再根据处理器类型获得适配器，通过适配调用Controller的方handle()并返回ModelAndView。
	在拓展时，只需要新建Controller类，以及它的Adapter，几乎不需要对现有代码修改

## 【桥接模式】Bridge ##
介绍：  
	1.将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变
	2.基于类最小设计原则，把抽象（Abstraction）与行为实现（Implementation）分离开
例子：    
	JDBC的Driver接口，
	在java.sql包下有一个Driver，在jdbc中，下面可以有mysql的Driver，oracle的Driver。与标准不太一样，直接使用DriverManager当为抽象类

应用场景：  
	适用于不希望使用继承或因为多层次继承导致系统类爆炸
	1.JDBC驱动系统	
	2.银行转账系统：
		转账分类：网上，柜台，ATM..
		用户类型：普通，银卡，金卡..
	3.消息管理
		消息类型：即时消息，延时消息
		消息分类：手机短信，邮件消息，QQ消息..

## 【装饰者模式】Decorator ##
介绍：  
	1.**动态将新功能附加到对象上**，扩展更有弹性，符合ocp
角色：
	Component主体，例如Drink
	ConcreteComponent具体的主体，例如单品咖啡，可以作一个抽象层，Coffee
	Decorator装饰者，例如Milk调料

![](https://img2020.cnblogs.com/blog/1603914/202004/1603914-20200408200327833-1923295879.png)

例子:  
	JDK中IO流中
	InputStream是一个抽象类，即Component  
	FilterInputStream就是一个装饰者，即Decorator  
	   	有一个注入的属性protected volatile InputStream in;就是被装饰的对象  
	而BufferedInputStream是FilterInputStream的子类，即具体的修饰者  
![Iamge](https://github.com/GKDHurryUp/imgs/blob/master/IO.png)

## 组合模式 Composite Pattern ##
介绍：  
1. 创建了对象组的树形结构，将对象组合成**树状结构**以表示“**整体-部分**”的层次关系  	
2. **用户对单个对象和组合对访问具有一致性**

角色：
1. Component：组合中对象声明接口，实现所有类共有的接口默认行为
2. Leaf：叶子节点
3. Composite：非叶子节点，用于存储子部件，在Component接口中实现子部件的相关操作，比如CRUD

例子：JDk中HaspMap使用到了组合模式
- Map与AbstractMap做了两层抽象，即Component
- HashMap是Map的实现类，实现了put，putAll方法，即Composite
- HashMap中的静态内部类Node，没有put，putALl方法，即Leaf

## 【外观模式】Facade ##
引入：
组建一个家庭影院，使用遥控器统筹个个开关，一个一个直接操作十分繁琐，设计一个高级遥控器，具有一键智能操作，自动操作多个设备

介绍：
1. 也称“过程模式，门面模式”，为子系统的一组接口提供一个一致额界面，定义一个高层接口，这个接口使得这一子系统更加容易使用
2. 定义一个一致的接口，屏蔽内部子系统的细节，调用端只需跟这个接口发生调用。

例子：MyBatis框架中Configuration创建MetaObject
- 在Configuration中聚合了DefaultObjectFactory、DefaultObjectWrapperFactory、DefaultReflectFactory来创建MetaObject
- 用户之间调用Configuration中的newMetaObject来创建即可

## 【享元模式】FlyWeight ##
引入：
小型外包项目，展示网站类型不同
- 新闻形式发布
- 博客形式发布
- 微信公众号形式发布

分析：
1. 需要网站结构相似度很高，而且都不是高访问量网站
2. 整合到一个网站中，共享相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源都可以共享
3. 由于是一份实例，易于维护和扩展

介绍：
1. 也称蝇量模式，运用共享技术有效支持大量细粒度的对象
2. 常用于**系统低层开发**，解决系统性能问题，如数据库连接池，里面都是创建好的连接对象，避免重新创建
3. 能够解决**重复对象的内存浪费问题**，系统中有大量相似对象，需要缓冲池时，从缓冲池里拿。
4. **经典应用场景**：池技术。如String常量池、数据库连接词、缓冲池

例子：JDK中的Integer使用享元缓存
- 在使用Integer.valueOf()时，会判断数据大小是否在缓存范围内，默认-128~127，如果不在范围内，则new一个新对象
		public static Integer valueOf(int i) {
			if (i >= IntegerCache.low && i <= IntegerCache.high)
				return IntegerCache.cache[i + (-IntegerCache.low)];
			return new Integer(i);
    	}
