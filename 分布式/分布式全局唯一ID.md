## 为什么需要分布式全局唯一ID？

在复杂分布式系统中，往往需要对大量的数据和消息进行唯一的标识 。对于各个系统之间相互调用、数据库分库分表之后都需要唯一ID来表示这些数据

## 全局ID的规则

1. 全局唯一

2. 趋势递增

   数据库插入时，B+树要求主键有序

3. 单调递增

   保证下一个ID一定大于上一个ID，事务版本号、IM增量消息

4. 信息安全

   若ID连续增加，可能造成泄露

5. 含时间戳

   了解该分布式id生成时间

## 全局ID的要求

1. 高可用
2. 低延迟
3. 高QPS



## 全局ID的方案

1. UUID（Universally Unique Identifier）

   - 不适合，过长，并且无序

   - 无网络消耗，唯一

2. 数据库自增id

   在单机下，使用数据库自增ID和mysql数据库的replace into（如果有，则先删除，再插入）

   分布式系统下：

   1. 系统水平扩展比较困难，需要设置增长步长
   2. 每次获取ID都需要读写数据库，性能得不到保障

3. 利用redis生成id
   因为Redis是单线程，可以保证原子性，在单机下，使用原子操作INCR和INCRBY来实现

   分布式系统下：

   1. 需要设置增长步长
   2. key设置有效期

    引入了Redis，还需要配置集群，成本过高，增加系统复杂度

4. Twitter的snowflake算法

5. 美团的Leaf分布式ID生成系统

   

## snowflake 雪花算法

最初Twitter把存储系统从MySQL迁移到Cassandra（FaceBook开发的NoSQL数据库系统），因为Cassandra没有顺序ID生成机制，所以开发了snowflake

![](../imgs\snowflake.jpg)

Snowflake使用long类型64bit存储id

1. 1bit，不用固定为0
2. 41bit，时间戳，毫秒级
3. 10bit，工作机器id
   - datacenterId 5位
   - workerId 5位

4. 12bit，序列号位，用来记录**同毫秒内**产生的不同id
   - 表示同一机器同一时间戳内产生的4095个ID序号

优点：

1. 毫秒高位，自增序列在低位，ID趋势递增
2. 不依赖数据库第三方系统，生成ID性能高

缺点：

1. 依赖机器时钟，若果机器时钟回拨，会产生重复ID

2. 在分布式环境上，每个服务器的时钟不可能完全同步，有时会出现不是全局递增的情况

   

## Leaf分布式ID生成系统

### Leaf-segment数据库方案

原方案每次获取ID都得读写一次数据库，造成数据库压力大。改为利用proxy server批量获取，每次获取一个segment(step决定大小)号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。 - 各个业务不同的发号需求用biz_tag字段来区分，每个biz-tag的ID获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对biz_tag分库分表就行。

### Leaf-snowflake方案

Leaf-snowflake方案完全沿用snowflake方案的bit位设计，即是“1+41+10+12”的方式组装ID号。使用Zookeeper**持久顺序节点**的特性自动对snowflake节点配置wokerID，除了每次会去ZK拿数据以外，也会在本机文件系统上缓存一个workerID文件。当ZooKeeper出现问题，恰好机器出现问题需要重启时，能保证服务能够正常启动。



## 为什么需要一致性Hash算法？ ##

在缓存集群中，由于需要将数据拆分，把不同的数据放入不同的缓存服务器中，最简单的一个方法就是，使用key求出hash值，再对缓存服务器的总数求余，根据这个编号分配到缓存服务器中。但是，如果想要新增缓存服务器，会使得大部分的缓存服务器失效。

## 一致性Hash算法 ##

1. 把Hash值围成一个环(0 - 2^32)
2. 对缓存集群的节点某个属性求hash值，放到环上
3. 对数据的key作一个hash运算，存放到顺时针方向上最近的那个节点
4. 此时若再加入一个节点，只会对两个节点之间的一部分数据造成影响，但是若放到环上的节点挨着比较近，仍然会有大部分数据影响
5. 此时，变向环中添加一些虚拟节点，让虚拟节点指向我们的数据节点

 