【什么是分布式系统？】
	分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像是单个相关系统。

【为什么需要分布式系统?】
	如今网站应用的规模不断扩大，常规的垂直应用架构已经无法应对，分布式服务架构以及流动计算架构已经成为主流趋势

【发展演变】
ORM->MVC->RPC->SOA

【单一架构的问题】
1.扩展
	修改服务项目需要重新打包，多台服务器都需要更改
2.协同开发
	多名开发人员同时修改可能会引起混乱。
3.性能
	随着应用的不断扩大，需要的内存不断增多，单台服务器甚至无法运行

【垂直架构的问题】
1.界面和业务逻辑耦合
2.应用之间不会完全独立，会相互交互

【分布式服务架构】

## 什么是RPC？ ##
远程过程(方法)调用（Remote Procedure Call）是一个计算机通信协议，在java中，就可以把**过程**理解为**方法**，允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外的为这个交互作用编程。

关键：
	1.通信速度
	2.序列化与反序列化速度
RPC框架：
	Dubbo(阿里)、gRPC(Google)、Thrift(Apache)、Spring Cloud、HSF（High Speed Service Framework）

## 远程调用原理

可以通过Controller把调用的一些信息传入到调用端，完成调用，但是这种方法并不方便。

我们可以把被调用端的信息，把它的接口放入到调用端的项目中，给这个接口生成一个**代理类**，获取到调用方的ip+端口号，把相应的参数，方法通过对应的协议（每个协议都有自己的特殊，数据大小等待）发送到被调用方，再接收相应的返回值

## 传统Nginx反向代理的缺点与改进 ##

缺点：
1. Nginx做反向代理时进行负载均衡，需要在配置文件中一个一个配置服务地址
2. 临时增加服务器时，需要停掉服务，重新启动

改进：
1. 通过一个注册中心，把相应的服务自动注册到注册中心中
2. 客户端通过注册中心拿到相应所有服务的地址，在客户端处进行负载均衡算法
3. 临时增加服务器时，会自动注册到注册中心，客户端的服务器地址会自动更新

## Service Mesh

Dubbo在业务中或多或少会有相应耦合，需要改业务代码。Service Mesh进一步解耦，通过一个进程绑定在client端称为sidecar，通过sidecar来进行服务之间的调用，避免代码的侵入

## Dubbo

前身为阿里开发，后开源交给了给了apache
特点：
	1.面向接口代理的高性能RPC调用
	2.智能负载均衡
	3.支持多种注册中心，服务自动注册与发现
	4.运行期流量调度，配置路由规则，实现灰度发布
	5.高度可拓展
	6.可视化服务治理与运维

提供服务配置：
	1.指定当前服务/应用的名字
		application
	2.指定注册中心的位置（注册中心类型，ip地址端口）
		registry
	3.指定通信规则（通信规则、通信端口）
		protocol
	4.暴漏服务(接口，接口真正的实现对象)
		service

消费者配置：
	1.指定当前服务/应用的名字
		application
	2.指定注册中心的位置（注册中心类型，ip地址端口）
		registry
	3.声明需要调用的远程服务的接口；生成远程服务代理
		reference
		
配置覆盖策略：
	虚拟机参数 -D -> XML -> Properties
	
超时配置：
	1.精确优先（方法及优先，接口次之，全局配置再次之）
	2.消费者优先，提供方次之
	
高可用：
	注册中心宕机后，服务提供者和服务消费者仍然可以通过本地缓存通讯
	还可以使用dubbo直连

## Dubbo支持的协议

Dubbo支持dubbo、rmi、hessian、http、webservice、thrift、redis等多种协议

1. dubbo 协议

   dubbo 缺省协议 采用单一长连接和NIO异步通讯

   优点：适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况

   缺点：不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。
   
   

## 为什么dubbo支持这么协议？

不同服务在性能上适用不同协议进行传输，比如大数据用短连接协议，小数据大并发用dubbo长连接协议，不确定数据类型使用http协议，稳定。在不同服务上支持不同协议或者同一服务上同时支持多种协议

## Dubbo支持的序列化方式

1. Hessian2
2. Java
3. JSON - fastjson
4. Fst
5. Avro
6. Kryo

## 负载均衡：

​	1.权重随机（默认）
​	2.权重轮询
​	3.最少活跃数
​		调用上一次请求花费了最少时间的服务器
​	4.一致性hash
​		在Hash算法的基础上实现的，用于解决互联网中热点Hotspot问题
​		1.求出不同服务器的哈希值，然后映射到一个范围为0 — 2^32-1的数值空间的圆环中，即将首(0)和尾(2^32-1)相接的圆环
​		2.有用户访问时，分配一个随机数，随机映射到圆环中的某一个位置，按照顺时针方向查找距离最近的服务器
​		3.容错性和可扩展性好，一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据
​		4.一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜

服务降级：
	当服务器压力剧增的情况下，根据实际业务情况以及流量，对一些服务和页面有策略的不处理或者换种简单的方式进行处理
	从而释放服务器资源，保证核心交易正常运行
	1.force:return+null
		在客户端直接返回null。屏蔽不重要服务
	2.faile:return+null
		远程调用失败后，返回null。容忍不重要服务

集群容错：
	1.Failover Cluster 失败自动切换 
	2.Failfast Cluster 只发起一次调用。使用于非幂等写操作
	
【幂等，非幂等】
幂等：
	查询、删除、修改。每次运行产生一样的效果，可设置重试次数
非幂等：
	新值。每次产生不一样的效果，不能设置重试次数

【Dubbo原理】
Dubbo是一个RPC框架，为了使得远程调用的一系列复杂繁琐的操作对程序员变得透明。
只需要调用，获得最终结果即可。
底层使用netty框架进行通信，netty基于NIO多路复用

## Java SPI的问题 ##
Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的接口，它可以用来启用框架扩展和替换组件。 如数据库Driver接口，mysql的jar包下META-INF/services里会提供自己具体的实现类，然后就会通过反射来创建出具体的实现类。

1. 不能单独的获取某个指定的实现类，只能遍历所有的实现，并全部实例化。
2. 配置文件中只是简单的列出了所有的扩展实现，而没有给他们命名。导致在程序中很难去准确的引用它们。
3. 没有IOC和AOP机制，不易与其他框架继承

## dubbo SPI ##
dubbo对java原生的spi机制作出了一定的扩展，使得其功能更加强大。

1. 扩展点：一个接口。

2. 扩展：扩展（接口）的实现。

3. 扩展自适应实例：其实就是一个Extension的代理，它实现了扩展点接口。在调用扩展点的接口方法时，会根据实际的参数来决定要使用哪个扩展。dubbo会根据接口中的参数，自动地决定选择哪个实现。

4. @SPI:该注解作用于扩展点的接口上，表明该接口是一个扩展点。

5. @Adaptive：@Adaptive注解用在扩展接口的方法上。表示该方法是一个自适应方法。Dubbo在为扩展点生成自适应实例时，如果方法有@Adaptive注解，会为该方法生成对应的代码。



# dubbo源码

## 服务暴漏

Dubbo服务的导出过程基于spring容器发布刷新事件，Dubbo在接受到事件后，会立即执行服务的导出逻辑

ServiceBean 是 Dubbo 与 Spring 框架进行整合的关键，可以看做是两个框架之间的桥梁。

首先Spring IOC容器进行启动，等到启动之后，会有ServiceBean注入到容器中，它会触发一个onApplicationEvents事件， 来进行export服务导出

1. 前置工作，主要是检查参数（配置文件）、组装URL（根据配置文件，组装URL ，通过传递URL，来传递配置信息）

   在Dubbo中，URL的作用十分重要，==采用URL作为配置信息的统一格式，通过传递URL来传递配置信息==。URL类相当于一个总线机制，注册中心保存的是一个URL封装好的数据，里面保存了一些ip地址、端口号、协议类型等

2. 导出服务，包含导出服务到本地（JVM）和导出服务到远程（**多协议多注册中心导出服务**）

3. 向注册中心注册服务，用于服务的发现

通过代理工厂获取代理对象进行invoke

