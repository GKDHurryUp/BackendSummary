
## 应用场景 ##
1. 互联网秒杀
2. 抢优惠券
3. 接口幂等性

## 为什么需要分布式锁？ ##
JVM的锁synchronized、lock只能在JVM进程内生效，无法跨进程

## 为什么不使用MySQL做分布式锁？

1. 性能
2. 需要设置锁的有效期，使用MySQL还需要额外的工作，而Redis本身就可以实现

## JMeter压测工具 ##

## Redis分布式锁 ##
SETNX key value，若key已经存在，不做任何动作
注：SETNX是SET if Not Exists

### 1.0简单版 ###
在执行业务逻辑前，添加一个key，value设置为任意值，判断如果SETNX命令返回true才继续执行，执行完成后删除key

问题：
1. 执行业务逻辑可能发生异常，造成key一直存在redis中
2. 如果在业务逻辑执行时，服务器宕机，造成key一直存在redis中
3. SETNX和expire不是原子操作，有可能设置完key，服务器宕机，造成key一直存在redis中
4. 如果业务执行时间比超时时间还要长，别的访问可能会删除不是自己的锁
5. 如果业务执行时间比超时时间还要长，业务代码块不能保证同步

解决：
1. 删除key要放在finally里面
2. 设置key的过期时间
3. 使用一条原子性指令 SETNX和过期时间
4. 在value中添加自己的id
5. 在业务代码中开启一个分线程，对锁进行定时延长过期时间

## Redisson分布式锁实现原理 ##

API上，使用redisson的getLock()拿到锁对象，使用它进行lock()、unlock()	

线程加锁成功后，开启后台线程，每隔十秒检测是否持有锁，如果有则延长锁时间(30s)其他线程获取锁失败，则while循环尝试加锁



底层使用lua脚本语言，保证原子块执行，使用hset把key，value存入redis中，并且设置过期时间（30s）

## Redlock原理 ##
主从架构下，Redisson如何解决主节点挂掉，锁失效的问题？使用**Redis Distributed Lock**锁的算法实现了多redis实例的情况，优点在于防止了单节点故障造成整个服务停止运行的情况

Redlock，即使锁定资源的服务崩溃或者分区，仍然能释放锁，超过半数redis节点加锁成功才算加锁成功



## 如何瞬间提高锁的并发量？ ##
借鉴ConcurrentHashMap的思想，把数据分拆分，分段存储，多个线程对不同的库存段进行操作

## Zookeeper实现分布式锁 ##

### 思路

首先创建一个lock持久节点，然后在lock节点下创建临时序号节点，释放锁的时候删除该临时节点。客户端调用createNode方法在lock下创建临时序号节点，然后调用getChildren("lock")获取lock下的所有子节点

- 如果发现自己的节点序号最小，就代表获得了锁
- 如果不是，说明没有获得锁，需要找到比自己**节点序号小的**那个节点，对它注册事件监听器Watcher

当前一个节点被删除时，客户端的Watcher会收到通知，再次重复上述步骤

### 阻塞锁

多个系统同时调用同一个资源，所有请求被排队处理。已经得到分布式锁的系统，进入运行状态完成业务操作；没有得到分布式锁的线程进入阻塞状态等待，当获得相应的信号并获得分布式锁后，进入运行状态完成业务操作

### 非阻塞锁

多个系统同时调用同一个资源，当某一个系统最先获取到锁，进入运行状态完成业务操作；其他没有得到分布式锁的系统，就直接返回，不做任何业务逻辑，可以给用户提示进行其他操作。

### 读锁 ###
1. 创建临时序号节点
2. 获取所有序号比自己小的节点，判断是否全部为读节点
	- 若是，则获取成功
	- 若否，添加父节点监听，当写锁完成时再去判断	 

### 写锁 ###
2. 获取所有序号比自己小的节点，判断是否全部为无锁节点
	- 若是，则获取成功
	- 若否，添加父节点监听，当写锁完成时再去判断


问题：
1. 如果排队等待的节点很多，每个节点都会添加监听，都会去查询父节点（羊群效应）

解决：

1. 进行链表监听，不监听父节点，而监听上一个节点，如果上一个节点状态发生变更，本节点就会收到通知	