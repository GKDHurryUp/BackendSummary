## 分布式事务-跨库

使用2PC两阶段提交解决

在执行提交时，会把涉及到的表锁住，性能会变低



## JTA/XA规范

XA：分布式事务的**协议**。定义了事务管理器和资源管理器之间的接口。

JTA：Java Transaction API， 满足XA规范、用于Java开发的规范

2PC是规范的**具体实现**

需要JDBC和数据库支持就可以使用JTA/XA事务，第二阶段（提交，回滚）有可能失败

## 两阶段提交协议

两阶段提交协议（Two-phase Commit，2PC）经常被用来实现分布式事务。一般分为协调器TC和若干事务执行者Si两种角色

![](..\imgs\2PC.png)

1. 服务Client端发起一个请求到TC

2. TC先将`<prepare>`消息写到本地日志，然后向所有数据库发出`<prepare>`消息

3. 数据库收到后，执行本机事务，但不进行commit

   - 若成功，返回`<yes>`
   - 若失败，返回`<no>`

   同理需要记录日志，当做凭证

4. TC收集所有执行器返回的消息
   - 若所有执行器都返回yes，那么给所有数据库发生送commit消息
   - 若有任一个执行器返回no，那么给所有数据库发送abort消息，数据库收到abort消息后执行事务回滚操作

问题：

- 两阶段提交涉及多次节点间的网络通信，通信时间太长
- 事务时间相对于变长了，锁定的资源的时间也变长了，造成资源等待时间也增加好多



## atomikos

![](..\imgs\atomikos.jpg)

atomikos对数据源进行代理封装，在操作数据库之前进行全局事务开启，操作完成之后进行提交



## 分布式事务-微服务

### TCC两阶段补偿型方案

会把全局锁减小到每个系统中每个API调用的接口上，再操作之后会迅速释放锁。可以支持大高并发量

## TCC分布式事务

TCC是Try-Confirm-Cancel的简称，不依赖资源管理器对XA的支持，而是通过业务系统提供的业务逻辑调度来实现分布式事务

Try阶段：

  完成所有业务检查（一致性），预留业务资源(准隔离性)

Confirm阶段：

  确认执行业务操作，不做任何业务检查， 只使用Try阶段预留的业务资源。

Cancel阶段：

   取消Try阶段预留的业务资源。

![](..\imgs\TCC.png)

缺点：

1. 是需要我们编写业务逻辑来实现，存在耦合
2. 代码开发量很大，要保证数据一致性 `confirm` 和 `cancel` 接口还必须实现幂等性

## TCC分布式框架

tcc-transaction

ByteTCC

Seata



## TCC两阶段提交与XA两阶段提交的区别

 XA是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁

 TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁

## AT模式

AT 模式是一种无侵入的分布式事务解决方案，AT 模式下，把每个数据库被当做是一个  Resource，Seata 里称为 DataSource Resource。业务通过 JDBC 标准接口访问数据库资源时，Seata 框架会对所有请求进行拦截，做一些操作，每个本地事务提交时，Seata RM（Resource Manager，资源管理器） 都会向 TC（Transaction Coordinator，事务协调器） 注册一个分支事务

![](..\imgs\AT.png)

TC：事务协调器

​	控制全局事务的开启，提交回滚

TM：事务管理器

​	负责定义事务的边界，负责发起开启一个全局事务、提交事务，回滚事务

RM：资源管理器

​	事务执行者，控制本分支事务的提交和回滚

一阶段：

Seata 会拦截“业务 SQL”，首先解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，然后执行“业务 SQL”更新业务数据，在业务数据更新之后，再将其保存成“after image”

二阶段：

第二阶段会根据第一阶段的情况决定是进行全局提交还是全局回滚操作。

阶段一提交成功，释放本地事务锁，阶段二什么也不做，因此seata比传统的两段式XA模式性能要好很多，真实业务中大部分事务也是成功的，没必要全程占有锁。



这种处理方式减少了XA两阶段提交的锁的时间，而且并不依赖于数据库本身的回滚机制，靠的是TC这个server端维护这一次XID中各个单体服务的执行状态，回滚时靠着自己保存的回滚语句进行回滚。可以明显提高各事务的并发执行。

## CAP理论

只能同时满足两项，要么CP，要么AP
1.一致性	
先同步
2.可用性
先反还数据，后同步
3.分区容错性
不影响整体对外提供服务

## BASE理论

对CAP理论的延伸，无法做到强一致性，但是可以采取适当的弱一致性，即最终一致性
基本可用
软状态
最终一致性



