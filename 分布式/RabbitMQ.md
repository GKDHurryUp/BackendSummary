## MQ是为了解决什么而出现的？

本质上解决通信的问题，两个系统之间实现的通信协议不同，专门出现一个中间系统来进行代理，进程存储转发消息

## 为什么要使用MQ？

1. 异步

   避免客户端等待，直接作出相应

2. 解耦

   一个服务调用另外多个服务，由消息队列转发到下游服务，上游服务不需要关心下游服务地址、是否调用成功等信息，完成服务之间依赖关系的解耦

3. 削峰

   队列具有先进先出的特性，把高峰期请求发送到MQ服务器，MQ中的消息队列再进行一个个的处理

## 为什么要有AMQP？

JMS是Java EE中的规范，使用相同Java接口操作不同的MQ产品（API）

由于JMS是跟Java语言绑定的，做不到真正跨语言跨平台，因此出现了AMQP（Advanced Message Queue Protocol）

AMQP位于应用层

## 消息发送到MQ中是存储在哪里的？

存储在Queue队列中

有两种：

1. 基于内存的节点

2. 基于内存和硬盘的节点，使用erlang开发的Mnesia数据库

## 如何确保消息正确地发送至RabbitMQ？

### 1. 使用AMQP的事务机制实现

1. channel.txSelect()声明启动事务模式；
2. channel.txComment()提交事务；
3. channel.txRollback()回滚事务；

这种方式需要发送端与服务器端进行**多次应答**， **性能很差**

### 2. 发送方确认模式

RabbitMQ使用发送方确认模式，确保消息正确地发送到RabbitMQ。

将信道设置成confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。一旦消息被投递到目的队列后，broker就会发送一个确认给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了。如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出。

如果RabbitMQ发生内部错误从而导致消息丢失，会发送一条nack（not acknowledged，未确认）消息。

发送方确认模式实现有三种：

1. 普通

   同步等待单条消息被服务器确认

2. 批量

   同步方式等所有的消息被服务器确认

3. 异步

   生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。

## 如何确保消息接收方消费了消息？

接收方消息确认机制，消费者接收每一条消息后都必须进行确认，只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。这里并没有用到超时机制，RabbitMQ仅通过Consumer的连接中断来确认是否需要重新发送消息。

- 如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要根据bizId去重）
- 如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息。

## 如何避免消息重复投递或重复消费？

在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进入队列

在消息消费时，要求消息体中必须要有一个bizId（对于同一业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重和幂等的依据，避免同一条消息被重复消费。

## 死信队列和延迟队列

死信队列 是 当消息在一个队列 因为下列原因：

1. 消息被拒绝（Basic.Reject或Basic.Nack）并且设置 requeue 参数的值为 false
2. 消息过期了
3. 队列达到最大的长度

在定义业务队列的时候，可以考虑指定一个死信交换机（DLX，Dead-Letter-Exchange），并绑定一个死信队列，当消息变成死信时，该消息就会被发送到该死信队列上，这样就方便我们查看消息失败的原因了

# RabbitMQ

RabbitMQ是由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现，使用GO编写

![](..\imgs\RabbitMQ.jpg)

## RabbitMQ工作流程

Producer通过Channel发送消息到MQ服务器中，实际上是发送到交换机（Exchange），首先会根据消息中的路由键（Routing Key）对应到绑定键（Binding Key），然后转发到对应的消息队列上（Queue），消费者端（Consumer）监听消息队列来获得消息

## 核心概念

### Message

消息，消息不具名的，由消息头和消息体组成。消息体不透明，消息头由一系列可选属性组合而成，routing-key（路由键）、priority（优先权）、delivery-mode

### Publisher

消息生产者，也就是向交换器发布消息的客户端应用程序

### Exchange

交换器，用来接收生产者发送的消息，并根据消息中的**路由信息**转发到相应的队列

类型：direct（默认），fanout，topic，headers

### Queue

消息队列，用来保存消息直到发送给消费者

### Binding

绑定，用于消息队列和交换器之间的关联。一个绑定就是**基于路由键**将**交换器**和**消息队列**连接起来的路由规则（路由表）	

### Connection

网络连接，如TCP连接

### Channel

信道，多路复用连接中的一条独立双向数据流通道。建立在真实TCP连接内的虚拟连接，因为**建立与销毁**TCP都需要**非常昂贵的开销**，使用信道概念来**复用**TCP，只需要创建和释放Channel即可

### Consumer

消息的消费者，表示一个从消息队列中取得消息的客户端应用程序

### Virtual Host

虚拟主机，表示一批交换器、消息队列和相关对象。

每个vhost本质上就是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器、绑定和权限机制

类似于namespace、package的概念

### Broker

表示消息队列服务器实体



## 运行机制

客户端发送消息到虚拟主机中，根据交换器的规则，匹配添加到不同的队列中

### direct

点对点模式，消息中的路由键和Bingding中的binding key一致，交换器就将消息绑定到对应的队列中

### fanout

广播模式，每个消息会分到所有绑定的队列上去

### topic

路由键和某个模式进行匹配，根据模式将消息绑定到相应的队列上去

通配符：#匹配0个或多个单词，*匹配一个单词