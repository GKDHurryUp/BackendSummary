## 完全二叉树

若设二叉树的深度为k

1. 除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数
2. 第k 层所有的结点都**连续集中在最左边**

## 二叉查找树 Binary Search Tree

1. 左子树上所有结点的值均小于它的根结点的值
2. 右子树上所有结点的值均大于它的根结点的值
3. 左、右子树也分别为二叉查找树
4. 没有键值相等的结点

插入、删除、查找的复杂度都为：
$$
O(log_2 N)-O(N)
$$


### 极端情况下： ###
1. 完全二叉树
2. 每层只有一个节点，退化成链表

### 线性结构数组（二分法）： ###
查询：
$$
O(log_2 N)
$$
插入、删除：
$$
O(N)
$$

### 总结： ###
- 二叉搜索树相对于线性结构，在构造复杂度和删除复杂度方面占优；在查询复杂度方面，二叉搜索树可能存在类似于斜树，每层上只有一个节点的情况，该情况下查询复杂度不占优势。
- 树中节点需要额外的空间保存节点之间的父子关系，所以在存储消耗上要高于线性结构。

## 平衡二叉树 AVL ##
也称自平衡二叉搜索树（Self-Balancing Binary Search Tree），本质也是一颗二叉搜索树。为了避免出现倾斜，对二叉搜索树中每个节点的左右子树作了限制。
树左右子树的高度差称之为平衡因子，**树中每个节点的平衡因子绝对值不大于 1**，此时二叉搜索树称之为平衡二叉树。

自平衡是指，在对平衡二叉树执行插入或删除节点操作后，可能会导致树中某个节点的平衡因子绝对值超过 1，即平衡二叉树变得“不平衡”，为了恢复该节点左右子树的平衡，此时需要对节点执行旋转操作。

### 总结： ###
相对于二叉搜索树，平衡二叉树避免了向线性结构演化的倾向，查询、插入和删除节点的时间复杂度为 
$$
O(log_2N)-O(log{\frac{1+\sqrt5}2}N)
$$
因为每个节点上需要保存平衡因子，所以空间复杂度要略高于二叉搜索树

## 红黑树 ##
红黑树是一种平衡二叉查找树的变体，它的左右子树高差有可能大于 1，所以红黑树**不是严格意义**上的平衡二叉树（AVL），但对之进行平衡的代价较低， 其**平均统计性能要强于** AVL，提供**O(log N) 级别的查询、插入和删除**节点复杂度。相对于 AVL 树单纯的对每个节点的平衡因子进行判断，红黑树给节点赋予了颜色属性，并**通过对树中节点的颜色进行限制**，来保持整棵树的**平衡**。查找时不需要颜色信息。

1. 节点是红色或者黑色；
2. 根节点是黑色；
3. 叶子节点是黑色；
4. 红色节点必须具有两个黑色子节点；
5. 从任一节点到其后代的叶子节点路径中包含相同个数的黑色节点。

## B树

 B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构

B树是**一个节点可以拥有多于2个子节点的二叉查找树**

定义：

- 根节点至少有两个子节点
- 每个节点有M-1个key，并且以升序排列
- 位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间
- 其它节点至少有M/2个子节点

## B+树

B+树是对B树的一种变形树，它与B树的差异在于：

- 有k个子结点的结点必然有k个关键码。
- 非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。
- 树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。

## 树状数组

树状数组是一个查询和修改复杂度都为log(n)的数据结构。==主要用于查询任意两位之间的所有元素之和==，但是每次只能修改一个元素的值

树状数组和线段树很像，但能用树状数组解决的问题，基本上都能用线段树解决，而线段树能解决的树状数组不一定能解决。



**C[i] = A[i - 2k+1] + A[i - 2k+2] + ... + A[i];  //k为i的二进制中从最低位到高位连续零的长度**