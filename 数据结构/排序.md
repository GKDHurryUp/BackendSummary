![](..\imgs\排序算法.png)

| 排序方法 | 平均时间 | 最坏时间 | 最好时间 | 空间         | 稳定性 |
| :------: | :------: | -------- | -------- | ------------ | ------ |
| 插入排序 |          |          |          |              |        |
| 选择排序 |          |          |          |              |        |
| 冒泡排序 |          |          |          |              |        |
| 希尔排序 |          |          |          |              |        |
| 快速排序 |          |          |          | O(logn)~O(n) |        |
| 并归排序 |          |          |          |              |        |
|  堆排序  |          |          |          |              |        |
|          |          |          |          |              |        |
| 计数排序 |          |          |          |              |        |
|  桶排序  |          |          |          |              |        |
| 基数排序 |          |          |          |              |        |

## 希尔排序（Shell Sort）

希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，它会优先比较距离较远的元素。

思想：把数据按一定增量分组，每组直接进行插入排序

步骤：

1. 选择初始增量

 	2. 把数组按增量分组，每组进行排序
 	3. 缩小增量，重复2，直到增量为1

## 快速排序 ##

思想：过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序（递归调用）

性能：平均O(n log n) , 最好O(n log n), 最坏O(n2) 空间复杂度O(log n), 不稳定

步骤：
1. 设置一个中枢元素，一般取0，也就是最左边的元素
2. 设置高低指针i，j，高指针上的数组元素如果比中枢元素大向低移动，直到找到第一个比中枢元素小的元素，低指针同理向高移动
3. 交换高低指针的数组元素，重复2步骤，直到i<j
4. 此时i=j，交换中枢元素与指针上的元素，递归再次排序

		```java
	public static void sort(int[] nums, int low, int high) {
	    if (low >= high) return;// 程序出口, 要加等号，相等时数组长度为1，避免再次调用
	    int base = nums[low];
		int i = low, j = high;
	
	    while (i < j) {
	        while (nums[j] >= base && i < j) {
	            j--;
	        }
	        while (nums[i] <= base && i < j) {
	            i++;
	        }
	        if (i < j) {// 交换i，j位置上的元素
	            int temp = nums[i];
	            nums[i] = nums[j];
	            nums[j] = temp;
	        }
	    }
		// i和j相等
	    nums[low] = nums[i];
	    nums[i] = base;
	    //递归调用，i位置已经定好了，左半部分为start --- i-1，右半边部分为i+1 --- end
	    sort(nums, low, i - 1);
	    sort(nums, i + 1, high);
	}
	```

## 并归排序 ##
思想：归并排序也是基于分治法的，归并排序将待排序的元素序列分成两个长度相等的子序列，为每一个子序列排序，然后再将他们合并成一个子序列。

性能：平均O(nlog n), 最好O(nlong n), 最坏O(nlog n) 空间复杂度O(n), 稳定

步骤：
1. 将数组从中间分开，对两边分别排序。
2. 将两个有序的数组进行合并。


```java
public static void sort(int[] nums){
    int [] temp = new int[nums.length];
    sort(nums, 0, nums.length-1,temp);
}
public static void sort(int[]nums, int start, int end, int[]temp){
    if(start < end){
        int mid = (start+ end) >>> 1;
        sort(nums, 0, mid, temp);
        sort(nums, mid+1,end, temp);
        merge(nums, start, mid, end, temp);
    }
}

private static void merge(int[] nums, int start, int mid, int end, int[] temp) {
    int i=start,j=mid + 1, t=start;//分为两部分数组
    while(i<=mid && j<=end){
        if(nums[i] <= nums[j]){
            temp[t++] = nums[i++];
        }
        else {
            temp[t++] = nums[j++];

        }
    }
    while (i<=mid) temp[t++] = nums[i++];
    while (j<=end) temp[t++] = nums[j++];

    for(int x = start;x<=end;x++){
        nums[x] = temp[x];
    }
}
```

## 桶排序 ##

思想：将数组分到有限数量的桶里，每个桶子再个别排序，最后再进行合并。

性能：平均O(N), 空间复杂度O(N+M), 稳定

步骤：
1. 建立M个桶（LinkedList）
2. 每个桶中进链表的有序的插入
3. 把每个桶中的数据从小到大取出

对于一个待排序列，我们已知它的大概范围的时候，我们把这个范围分为n个相同大小的子区间，也就是我们说的桶，我们这里用数组的每一个元素代表一个桶。然后我们就可以把输入数据分到各个桶之中，因为我们前面假设了输入数据是均匀分布的情况，所以不会出现很多数落在同一个桶的情况。当然还是会出现多个数字落在同一个桶的情况，这时我们就会为当前桶生成一个链表，以此来维护一个桶之中的多个元素（像不像解决哈希冲突的拉链法）。对于一个桶之中的多个元素，我们使用插入排序，来保证这个链表是有序的。之后我们就获得了n个桶以及这n个桶对应的有序链表，我们遍历每个桶中的链表，就获得了排序的结果。



## 计数排序

计数排序算法不是基于元素比较，而是利用数组下标来确定元素的正确位置，**它适用于一定范围的整数排序**。在取值范围不是很大的情况下，它的性能在某些情况甚至快过那些O(nlogn)的排序，例如快速排序、归并排序

1. 当数列最大最小值差距过大时，并不适用于计数排序
2. 当数列元素不是整数时，并不适用于计数排序



## 排序稳定性的意义？

假如排序的内容是一个复杂对象的多个属性，并且原本的初始顺序存在意义，我们需要在二次排序的基础上保持原有排序的意义，就可以用到稳定性排序算法