# JVM虚拟机 #
## Java内存区域 -运行时数据区 ##
- 线程共享：
	堆，方法区(元空间)
- 线程私有：
	虚拟机栈，本地方法栈，程序计数器

1. 程序计数器：
	程序计数器是一块较小的内存空间，指向当前线程所执行的字节码指令的(地址)行号。
2. 虚拟机栈：
	- 在一个线程中，每个方法在执行的同时会创建一个**栈帧**（Stack Frame）用于存储**局部变量表、操作数栈、动态链接、方法出口**等信息。
	  - 动态链接：存放方法区的内存地址
	- 局部变量表：存放了编译期可知的各种**基本数据类型**，**对象引用**（reference）
	- 会出现两种异常：StackOverFlowError(栈超过最大深度) 和 OutOfMemoryError（栈空间不足）
3. 本地方法栈：
	和虚拟机栈所发挥的作用非常相似，虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈为虚拟机使用到的Native方法服务
4. Java堆
	- **唯一目的存放对象实例**，进一步的划分的目的是为了**更好地回收内存**，或者**更快的分配内存**。
	- Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC堆（Garbage Collected Heap）**
5. 方法区
	- 方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”
	- 储存**已被虚拟机加载的类信息**、**常量**、**静态变量**、**即时编译器编译后的代码**等数据。
	- 内存回收目标主要是针对常量池的回收和对类型的卸载（废弃常量， 无用的类）
	- JDK 1.8中**移除整个永久代**，取而代之的是一个叫**元空间（Metaspace）**的区域，元空间的本质和永久代类似，都是对**JVM规范中方法区的实现**，元空间与永久代之间最大的区别在于：**元空间并不在虚拟机中，而是使用本地内存**

### 操做系统的栈和堆

栈：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈

​		栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。

堆：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收

​		堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。



## 运行常量池 ##

用于存放编译期生成的各种**字面量**跟**符号引用**，这部分将在类加载后进入方法区的运行常量池中存放

JDK1.7之前：
- 运行常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用

JDK1.7及之后：
- JVM将	从方法区移出，在堆中开辟了一块内存区域存放

字面量：自己定义的常量，“ABC”，0，2

符号引用：以一组符号来描述所引用的目标，只要使用时能够无歧义的定位到目标即可

## Java对象的创建过程 ##
1. 类加载检查
	虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到这个**类的符号引用**，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过
2. 分配内存
	对象所需要的内存大小在类加载完成后便可确定，为对象分配空间任务等同于把一块确定大小的内存从Java堆中划分出来。分配方式有两种：“指针碰撞”和“空闲列表”
3. 初始化零值
	内存分配完成，JVM将分配到的内存空间都初始化为0值，保证对象的实例字段在Java代码中可以不赋值初始值就直接使用
4. 设置对象头
	需要对对象进行必要的设置，如这个对象是那个类的实例、如何能找到类的元数据信息、对象的哈希码。GC分代年龄等信息。根据运行状态，是否启用偏向锁，对象头有不同的设置
5. 执行init方法
	上面完成之后，从虚拟机的角度来看，一个对象产生了。但是从程序员的角度来看，对象创建才刚开始，需要执行<init>方法，把对象按照程序员的遗愿进行初始化

## 对象内存分配

### 内存分配的两种方式 ###

1. 指针碰撞
	- 适合堆内存规整（没有内存碎片）
	- 用过的内存都整合到一边，没有用过的在另一边，中间有一个分界指针，只需要想没有使用过的内存方向移动对象大小位置即可
2. 空闲列表
	- 适合堆内存不规整
	- 虚拟机维护一个列表，列表中记录哪些内存块是可用的，在分配的时候，找一块足够大的内存块划分给对象实例，并更新列表记录

### 内存分配并发问题

在创建对象的时候必须要保证线程安全

1. 逃逸分析，首先尝试栈上分配
2. TLAB(Thread Local Allocation Buffer)
   为每个线程预先在Eden区分配一块内存，JVM在线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存，再采用CAS分配
3. CAS+失败重试
   CAS是乐观锁的一种实现方式，每次不加锁而是假设没有冲突而去完成某项操作，如果冲突失败就重试，值到成功

### 栈上分配

其实有很多的对象的作用域都不会逃逸出方法外，也就是说该对象的生命周期会随着方法的调用开始而开始，方法的调用结束而结束，如果在栈上分配该对象，**随着栈帧的弹出，回收空间直接被回收掉，避免GC**

### 栈上分配如何开启

前提：

- 开启逃逸分析 (-XX:+DoEscapeAnalysis)
- 开启标量替换 (-XX:+EliminateAllocations)

### 为什么需要TLAB

对象分配在堆上，而**堆是一个全局共享**的区域，当多个线程同一时刻操作堆内存分配对象空间时，需要同步（CAS+重试）

Thread Local Allocation Buffer，线程本地分配，每个线程分配对象到堆空间时，先分配到自己所属的那一块堆空间，避免同步带来的效率问题，从而提升分配效率

### TLAB原理

实现位于`/Users/zhanjun/openjdk/hotspot/src/share/vm/memory/threadLocalAllocBuffer.hpp`

```cpp
// ThreadLocalAllocBuffer: a descriptor for thread-local storage used by
// the threads for allocation.
//            It is thread-private at any time, but maybe multiplexed over
//            time across multiple threads. The park()/unpark() pair is
//            used to make it avaiable for such multiplexing.
class ThreadLocalAllocBuffer: public CHeapObj<mtThread> {
  friend class VMStructs;
private:
  HeapWord* _start;                              // address of TLAB
  HeapWord* _top;                                // address after last allocation
  HeapWord* _pf_top;                             // allocation prefetch watermark
  HeapWord* _end;                                // allocation end (excluding alignment_reserve)
  size_t    _desired_size;                       // desired size   (including alignment_reserve)
  size_t    _refill_waste_limit;                 // hold onto tlab if free() is larger than this
```

TLAB简单来说本质上就是三个指针：start，top 和 end，每个线程都会从Eden分配一大块空间，作为自己的TLAB，其中 start 和 end 是占位用的，标识出 eden 里被这个 TLAB 所管理的区域，卡住eden里的一块空间不让其它线程来这里分配。而 top 就是里面的分配指针，一开始指向跟 start 同样的位置，然后逐渐分配，直到再要分配下一个对象就会撞上 end 的时候就会触发一次 TLAB refill

## 对象的内存布局 ##

1. 对象头（Header）
	第一部分（Mark Word）：对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳
	第二部分：指针类型，对象指向它的类元数据的指针，JVM通过这个指针来确定这个对象是哪个类的实例。
2. 实例数据（Instance Data）
	程序代码中定义的各种类型的字段内容，包括从父类中继承下来的
3. 对齐填充（Padding）
	非必然存在，仅起着占位符作用

## 对象的访问定位 ##
1. 句柄访问
	Java堆中划分出一块内存作为句柄池，reference存储对象句柄地址，而句柄中包含对象实例数据与对象类型数据的具体地址信息	
	好处：对象被移动只需要改变句柄中的实例数据指针，而reference不需要修改
2. 直接指针（HotSpot）
	reference中储存的直接就是对象实例数据地址
优点：访问速度快，节省了一次指针定位的时间开销


# 垃圾收集器与内存分配策略 #

## 如何判断对象是否死亡 ##
1. 引用计数法
	在对象中添加一个引用计数器，每有一个地方引用它，计数器+1；
	引用失效时计数器-1，计数器为0的对象就是不可能在使用的
	难以解决循环引用的问题
2. 可达性分析算法
	通过一系列“GC Rotts”的根对象作为起始节点集，根据引用关系向下搜索，搜索过程做过的路径称为“引用链（Reference Chain）”， 某个对象到GC Roots间没有任何引用链，说明此对象是不可能在使用的

### GC Roots对象  ###
1. 虚拟机栈中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI（Java Native Interface）引用的对象

## 引用 ##
JDK1.2之前，引用的定义很传统，如果Reference类型的数据存储的数值代表的另外一块内存的起始地址，就称改Reference类型是代表某块内存、某个对象的引用
JDK1.2之后，进行了扩充

1. 强引用 StrongReference
	程序代码之中普遍存在的，如“Object obj = new Object()”,只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
	
2. 软引用 SoftReference
	还有用，但非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中。
	
	可以用于缓存，比如网页缓存、图片缓存
	
3. 弱引用 WeakReference
    也是非必需对象，但强度比软引用更弱一些。只能生存到在下一次垃圾收集发生之前。

4. 虚引用 PhantomReference
    最弱的一种。无法通过虚引用来获得一个对象实例，设置虚引用的唯一目的就是能在这个对象被GC回收时，收到一个系统通知。
    
     JVM自动管理堆内内存，无法自动管理直接内存，Unsafe类，NIO从网卡拷贝数据时，零拷贝使用虚引用指向堆外内存，而Gc回收了虚引用，但是堆外内存也需要回收，所以使用一种钩子机制，虚引用被回收时通知JVM进行堆外内存管理

	    NIO中，Buffer.allocetDirect()

## 回收方法区 ##
方法区的垃圾收集分为两部分：
1. 废弃常量
	与回收Java堆中的对象类似，若果发生内存回收，并且有必要，会清理出常量池
2. 不再使用的类型（判定无用的类）
	1. 该类的所有实例已被回收
	2. 加载该类的ClassLoader已被回收
	3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

## 垃圾收集算法 ##
从判断对象消亡的角度出发，垃圾收集算法可分为“引用计数式垃圾收集”（直接垃圾收集）和“追踪式垃圾收集”（间接垃圾收集）
1. 标记-清除算法 Mark-Sweep
	标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。效率低，而且会产生内存碎片
	
2. 复制算法 Copying
	将内存分为大小相同两块，每次使用其中一块。这个用完后，把还存活的对象复制到另一块去，然后把使用的空间一次清理掉
	效率可以，但是浪费空间
	
3. 标记-整理算法 Mark-Compact
	先进行标记，然后让所有存活的对象向一端移动，直接清理掉边界以外的内存
	
4. 分代算法
	新生代中，可以选择复制算法
	
	在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(默认15)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为“To”区域是空的。
	
	老生代中，可以选择标记-清除或者标记-整理

## 什么情况下会出现OOM？怎样发现和排查原因 ##
1. Java堆溢出：heap
	通过内存映像分析工具查看dump的内存快照分清楚是内存泄露（Memory Leak）还是内存溢出（Memory Overflow）
- 如果是内存泄漏，可进一步通过工具（如Jrockit等工具）查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象时通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。
	
	- 如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。
2. 栈溢出：stack
3. 运行时常量溢出   constant
4. 方法区溢出   directMemory

首先通过报错的异常可以发现是哪里出现了OOM，判断是内存泄露还是内存溢出

## 触发GC时机 ##
**Minor GC：**

1. Eden区满

**Full GC：**

1. 调用System.gc()，系统建议执行Full GC，但是不必然执行

2. 老年代空间不足 

  在发生Minor GC的时候，虚拟机会检测之前每次晋升到老年代的平均大小是否大于年老代的剩余空间，如果大于，则直接进行Full GC。

3. 方法区空间不足 

4. gc 担保失败
	
	在发生MinorGC前，检查老年代是否有连续空间,如果有,则执行,如果没有，根据设置:-XX:-HandlePromotionFailure 指定


## 堆内存中对象分配的基本策略 ##
**1. 堆划分**
- 在JDK1.7以及之前的版本中，堆内存通常被分为三块区域：新生代（1/3）、老年代（2/3）、永久代。
- 新生代又分为：Eden区、From Survivor区（S0）、To Survivor区（S1）。默认8-1-1。
- 在JDK1.8中，把存放元数据中的永久内存从堆内存中移到了本地内存(Native memory)
- JDK1.8也提供了一个新的设置Matespace（元空间）内存大小的参数，通过这个参数可以设置Matespace内存大小

**2. 基本策略**
- 对象优先在Eden分配
- 大对象直接进入老年代
- 长期存活的对象将进入老年代
- 动态对象年龄判定
	- Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于等于该年龄的对象直接进入老年代

## Class文件结构 ##
Class文件是一组8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑排列在Class文件，没有分隔符。当遇到需要占用8位字节以上空间的数据时，会按照高位在前的方式分割为若干8位字节进行存储，使用UTF-16编码（任何字符对应的数字都用两个字节来保存）
1. 魔数
2. Class文件版本号
3. 常量池
4. 访问标志
5. 当前类索引，父类索引
6. 接口索引集合
7. 字段表集合
8. 方法表集合
9. 属性表集合

# 类加载机制 #

## 类加载的生命周期 ##
![](http://static.zybuluo.com/Rico123/ojhhtids41ivtuowfj74mkb2/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B)

## 类初始化的时机 ##
（加载、验证、准备需要在此之前）
1. 遇到new、getstatic、putstatic或invokestatic这四条字节码指令
	- 使用new关键字**实例化对象**的时候
	- 读取或设置一个类的**静态字段**（被final修饰，已在编译器把结果放入常量池的静态字段除外）的时候
	- 调用一个类的**静态方法**的时候
2. 使用java.lang.reflect包的方法对类进行**反射调用**的时候，如果类没有进行过初始化，则需要先触发其初始化
3. 当初始化一个类的时候，如果发现其**父类**还没有进行过初始化，则需要先触发其父类的初始化
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类
5.  当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化
6. 一个接口中定义了JDK8中的**默认方法**，如果有这个**接口的实现类**发生了初始化，该接口要在其之前初始化

## 类加载的过程 ##
类加载过程：**加载->连接->初始化**
连接过程又分为：**验证->准备->解析**

1. 加载 Loading
	1. **通过一个类的全限定名来获取定义此类的二进制字节流**
		a.从ZIP包中，成为日后JAR、EAR、WAR格式基础
		b.从网络中获取，Applet
		c.运行时计算生成，动态代理
		d.其他文件，如JSP生成对应Class类
		e.从数据库中读取
	2. **将这个字节流代表的静态存储结构转为方法区的运行时结构数据**
	3. **在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口**
加载与连接阶段的部分内容是交叉进行的（如字节码文件格式验证动作）
	
2. 验证 Verification
	1. 文件格式的验证
	2. 元数据验证
	3. 字节码验证
	4. 符号引用验证
	
3. 准备 Preparation
	准备阶段主要为类变量（static）分配内存并设置初始值（数据类型默认值）
	概念上这些变量在方法区（JDK1.7在永久代，JDK1.8随Class对象在堆中）
	
4. 解析
	虚拟机将常量池中的符号引用转化为直接引用的过程
	
	解析阶段就是要把类常量池中类，字段，方法的符号引用转成可以使用的直接引用，一个类的解析就是通过类名查找类，并保存这个类的class对象的引用，有了class对象的直接引用才能使用这个类
	
5. 初始化

  ==获取到Class对象初始化锁的线程才能只能初始化，其他线程都要阻塞等待。==

  - 在初始化阶段，主要为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。
  - 初始化阶段是执行类构造器<clinit>()方法的过程。<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的
  - 虚拟机会保证一个类的类构造器<clinit>()在多线程环境中被正确的加锁、同步
  - 实例初始化不一定要在类初始化结束之后才开始初始化

## 类加载器 ##
1. 启动类加载器（BootstrapClassader）
	最顶层加载器类，由C++实现，负责加载%JAVA_HOME%/lib目录，或者-Xbootclasspath指定路径中的类，且java虚拟机能识别
2. 拓展类加载器（ExtensionClassLoader）
	负责加载%JAVA_HOME%/lib/ext目录下的类，或者被java.ext.dirs系统变量所制定的路径下的类库
3. 应用程序加载器（ApplicationClassLoader）
	也称为SystemAppClass ，面向用户的加载器，负责加载用户类路径ClassPath上的类库

## 双亲委派模型 ##
![](https://pics6.baidu.com/feed/b8014a90f603738d649f9e0e75127c55f919ecd0.jpeg?token=350c225e7426f8cc62948a0dbfe8e911&s=59A01D723F0A774915E1754F0200E0F2)
如果一个类加载器接收到了类加载的请求，它首先不会自己去尝试去加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载都是如此，因此所有的类加载请求都应该传送到顶层启动类加载器中，只有当父加载器反馈自己无法加载这个请求，子类加载器才会去尝试自己加载

### 双亲委派模型带来的好处 ###
双亲委派模型保证了Java的稳定运行，避免类的重复加载，保证核心API不被篡改。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。

### 为什么要打波双亲委派模型？ ###

它有一定的缺陷，有种情况是API调用用户代码的情况，如JNDI服务

JNDI：

JNDI由JNDI API、命名管理、JNDI SPI（service provider interface）服务提供的接口组成。我们的应用可以通过JNDI的API去访问相关服务提供的接口。

这些 SPI 的接口由 Java 核心库来提供，而这些 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进类路径（CLASSPATH）里。**SPI接口中的代码经常需要加载具体的实现类**。

SPI的接口是Java核心库的一部分，是由**启动类加载器(Bootstrap Classloader)来加载的；SPI的实现类是由应用程序类加载器(ApplicationClassLoader)**来加载的。引导类加载器是无法找到 SPI 的实现类的，因为依照双亲委派模型，BootstrapClassloader无法委派AppClassLoader来加载类。


### 如何打破双亲委派模型 ###

1. 可以自己定义一个类加载器继承ClassLoader，重写loadClass()

2. 使用线程上下文类加载器ThreadContextClassLoader

   如在Java的SPI中，它使用ServiceLoader来加载 META-INF/services中的实现类，它里面就是通过线程**getContextClassLoader**

