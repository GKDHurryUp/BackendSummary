# 垃圾回收器 #

## 简介 ##
一共有十种，其中六种是分代，其常用的组合：

1. Serial-Serial Old
2. Parallel Scavenge-Parallel Old（JDK8默认）
3. ParNew-CMS（ParNew是专门配合CMS的PS）

四种不分代：
1. G1 (JDK9默认， JDK8也可以用)

2. ZGC（颜色指针）

3. Shenandoah

4. Epsilon

   不执行任何垃圾回收工作，一旦java的堆被耗尽，jvm就直接关闭

垃圾回收器的发展是跟内存容量的不断增长有密切的关系，Serial在内存几十M的时候还可以，但是内存变大之后，相应需要STW的时间也就变长，此时这种方法就不适用了
Parallel算法 - 几个G，当内存空间继续大时，但它也需要STW，此时多线程之间的线程调度问题又出现了

## 详细介绍 ##
1. Serial（新生代）
	单线程收集器，在进行垃圾收集工作时需要STW，对于运行在Client模式下的虚拟机是一个很好的选择
2. ParNew（新生代，专门配合CMS使用的）
	Serial的多线程版本，运行在Server模式下的虚拟机首选，除Serial只有ParNew可以与CMS收集器配合工作
3. Parallel Scavenge（新生代）
	目标在于达到可控制的吞吐量，控制最大垃圾收集停顿时间、直接设置吞吐量大小，称被称为“吞吐量优先”收集器
4. Serial Old（老年代）
	单线程，标记整理法，也是主要用于Client。
	在Server模式下
	- 与Parallel Scavenge搭配
	- 作为CMS后备预案

5. Parallel Old（老年代）
	多线程，标记整理法
6. CMS（Concurrent Mark Sweep）
	标记-清除法
	目标：最短回收停顿时间，适合B/S系统Server端

	运行步骤：
	<1>初始标记
	<2>并发标记
	<3>重新标记
	<4>并发清除
7. G1
优点：
	<1>并行与并发
	<2>分代收集
	<3>空间整合
	<4>可预测的停顿
运行步骤：
	<1>初始标记
	<2>并发标记
	<3>最终标记
	<4>筛选回收

## CMS垃圾回收器 ##
Concurrent Mark Sweep

四个阶段：
1. initial mark（STW）
	初始标记只标记GC Roots能直接关联的对象，速度很快
	
2. Concurrent mark
	并发标记就是从GC Roots能直接关联的对象开始遍历整个对象图，用户线程和可以与垃圾收集线程一起并发运行，此时会发生错标，比如一个缓存，标记为无用，但是又增加引用，此时若清除会发送问题
	
	使用算法三色标记法，（Increment Update增量更新（CMS），STAB（G1））
	
3. remark（STW）
    重新标记就是为了修正并发标记期间，因用户程序继续运行导致标记发生变动的错标。

4. Concurrent sweep
    并发清除，不需要移动对象，可以并发清除


注：CMS有问题，没有任何一个JDK版本默认使用CMS

## CMS缺点 ##
1. 多线程（(默认CPU核+3)/4）清理占用系统资源，降低总吞吐量
2. 产生漏标，无法处理浮动垃圾，只能再下一次垃圾收集处理
3. 由于实质是“标记-清除”，会有大量空间碎片产生

注：2，3由于垃圾过多，空间不足，无法分配对象，会使用Serial Old产生STW的Full GC

## 并发标记的算法

CMS使用的是三色标记+Incremental Update算法
G1使用的是三色标记+snapshot at the begining （SATB）算法
ZGC： Colored Pointers+写屏障
Shenandoah ：Colored Pointers+读屏障

## 三色标记法 ##
黑色：自己标记，fields都完成标记
灰色：自己标记，fileds还未标记
白色：没有遍历到的节点

A->B->D
> 第一种情况：B->D消失，D为floating garbage
>
> 第二种情况：B->D消失，此时D被标记为垃圾，这时A->D增加，如果此时垃圾回收，D会被作为垃圾清除

1. CMS解决方案：Incremental Update 增量
	**关注引用的增加**，通过写屏障追踪指针变化，就将黑色标记为灰色，在remark重新标记。多个垃圾清理线程并发标记会产生漏标，由于存在ABA问题（如果发现黑色指向了白色，把黑色重新标记为白色），因此remark过程需要重新扫描属性。但是会造成重复扫描已扫描过的属性，需要STW时间长。
2. G1解决方案：STAB
	在B->D消失时，把这个引用推到GC的堆栈，保证D还能被GC扫描到，配合RSet（Remember Set），只用扫描到哪些Region引用到D这个Region了

## 颜色指针 ##
颜色指针是ZGC和Shenandoah的解决方案，它的思想是在指针上做研究，直接是在对象的Mark word存储信息的，而这种方法把对象的状态放到指针中，
高18位，未使用，中间四位本别代表不同的状态，后42位存放对象的地址（2^42 = 4T, 最大2^44 = 16T？（主板上的数组总线只支持48位））
Remmapped：对象正在移动


## G1垃圾收集器 ##
==逻辑分代，物理不分代==。G1将内存划分成了多个大小相等的Region（默认是512K）。同时每个Region被标记成E、S、O、H，分别表示Eden、Survivor、Old、Humongous。，把一些Region连起来形成Humongous

![](..\imgs\G1.jpg)

### 跨代引用

在进行Young GC的时候，==Young区的对象可能还存在Old区的引用==， 这就是跨代引用的问题。

G1引入了`Card Table` 和`Remember Set`的概念，基本思想就是用空间换时间。这两个数据结构是专门用来处理==Old区到Young区==的引用。Young区到Old区的引用则不需要单独处理，因为Young区中的对象本身变化比较大，没必要浪费空间去记录下来。	

RSet：全称Remembered Sets, 用来记录外部指向本Region的所有引用，每个Region维护一个RSet。

Card: JVM将内存划分成了固定大小的Card。这里可以类比物理内存上page的概念。

指针压缩

1. 节省内存空间
2. 加块程序执行效率

## Java指令 ##
  > 标准： - 开头，所有的HotSpot都支持
  >
  > 非标准（non-standard）：-X 开头，特定版本HotSpot支持特定命令
  >
  > 不稳定：-XX 开头，下个版本可能取消

## Linux查看进程状态相关指令 ##
1. top
	查看所有进制pid，cpu，内存等信息
2. ps -ef
	
2. jps
	查看java相关进制的pid
4. jinfo <pid>
	查看java程序启动的一些信息 
5. jstat -gc <pid> <milliseconds>
	每隔多少毫秒打印GC的情况
3. jstack <pid>
	定位线程状况，
	可以通过waiting on condition[]，发现死锁
7. jmap -histo <pid> | head -20（不能用于生成环境，堆会暂停）
	查看类的实例数，大小
	 线上系统，内存特别大，jmap执行期间会对进程产生很大影响，甚至卡顿（电商不适合）
    1：设定了参数HeapDump，OOM的时候会自动产生堆转储文件（不是很专业，因为多有监控，内存增长就会报警）
    2：<font color='red'>很多服务器备份（高可用），停掉这台服务器对其他服务器不影响</font>
    3：在线定位(一般小点儿公司用不到)

    4：在测试环境中压测（产生类似内存增长问题，在堆还不是很大的时候进行转储）

## 调优前基本概念 ##
1. 吞吐量
	用户代码时间/（用户代码时间+垃圾回收时间）
2. 响应时间
	STW越短，响应时间越好

**首先确定使用哪种垃圾回收算法？再确定追求什么**？吞吐量优先，还是相应时间优先？还是在满足一定的响应时间的情况下，达到多大的吞吐量

## 什么是调优？ ##
1. 根据需求进行JVM规划和预调优
2. 优化运行JVM运行环境（慢，卡顿）
3. 解决JVM运行过程中出现的各种问题（OOM）

## 调优原则

1. 最小堆、最大堆设置一致，防止内存抖动
2. 方法区设置物理内存1/32
3. 保持20~30%内存空余

## 调试工具 ##
1. jvisualvm（只能在测试环境使用，Windows下远程连接Linux）
2. jconsole（只能在测试环境使用，Windows下远程连接Linux）
3. arthas
	dashboard查看各个线程的信息
	jvm查看jvm相关的信息
	thread查看所有线程的，thread <id>查看具体的线程，thread -b查看死锁
	sc 搜索被JVM加载的类
	sm <Class> 列出类的方法
	trace 追踪类中的方法调用时间
	heapdump 把内存信息保存到dump文件中（堆会停止，服务暂停）

## arthas在线排查工具 ##
* jvm观察jvm信息
* thread定位线程问题
* dashboard 观察系统情况
* heapdump + jhat分析
* jad在线反编译
   动态代理生成类的问题定位
   第三方的类（观察代码）
   版本问题（确定自己最新提交的版本是不是被使用）
* redefine 热替换
   目前有些限制条件：只能改方法实现（方法已经运行完成），不能改方法名， 不能改属性
   m() -> mm()
* sc  - search class
* sm <Class> 列出类的方法
* watch  - watch method
* 没有包含的功能：jmap

## CPU飙高怎么检查？ ##
1. 使用arthas的dashboard或thread指令可以查看到哪个线程占用CPU较高
   或者使用jstack指令定位线程状况
2. 如果是GC线程，查看是否频繁GC
3. 如果是业务线程，thread <id>查看线程的具体信息，查看调用了哪些方法
	
## 内存飙高怎么排查？ ##
在测试环境可以使用jmap来查看类的实例数，大小
如何在生产环境，怀疑某个类，使用arthas来trace

## 为什么需要指针压缩？ ##
32位系统中，内存的大小只能支持到4GB。64系统中，所有应用程序运行时占用的空间都会比32位系统大1.5倍左右，这是因为指针占用的空间增加了。虽然内存是比较廉价的，但网络带宽和缓存容量是紧张的。所以，为了解决4GB的限制而增加堆内存的占用空间，就有些得不偿失了。

## 为什么最小堆和最大堆要设置成一样的？ ##
JVM会根据最小堆和最大堆的大小进行弹缩，不断的
32位机最大内存为2的32次方
64位机的==最大内存为2的48次方==（目前支持主板制造） 256T


## 一个空对象占多少字节？为什么？ ##
在Hotspot下，64位机，首先Hotspot虚拟机要求对象的大小必须是8的整数倍
指针压缩关闭，共16字节：	

1. markword 64位，8个字节
2. 类型指针  64位，8个字节
3. 实例数据  0个字节
4. 补齐		0个字节

指针压缩开启，共16字节：
1. markword 64位，8个字节
2. 类型指针  32位，4个字节
3. 实例数据  	0个字节
4. 补齐			4个字节

## Object o = new Object()占多少字节？ ##
在Hotspot下，64位机
指针压缩关闭：
Object o 引用占8个字节，加上对象的，一共24个字节
指针压缩开启：
Object o 引用占4个字节，补齐4个字节，一共8个字节，加上对象的，一共24个字节

## 指针压缩是如何实现的？如何证明开启指针压缩节省了内存？ ##
Hotspot虚拟机要求对象的大小必须是8的整数倍，后三位永远为0，因此在存储的时候把后三位抹去，访问的时候往后三位添加0

## 开启指针压缩后，一个oop所能表示的最大堆空间是多少？不开启呢？ ##

注：oop（ordinary object pointer），即普通对象指针，是JVM中用于代表引用对象的句柄。
## 如何扩展开启指针压缩后一个oop所能表示的最大堆空间 ##

## 对象的内存布局何时会出现两段填充 ##
数组对象在关闭指针压缩的情况下