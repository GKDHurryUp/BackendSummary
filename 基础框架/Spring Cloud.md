# 微服务

微服务架构是一种架构模式，提倡将单一应用程序划分成一组小的服务，服务之间相互协调、互相配合，为用户提供最终价值

每个服务运行在**其独立的进程**中，服务与服务间采用轻量级的通信机制互相协作（基于HTTP的Restful API）

每个服务都围绕具体业务进行构建，能够独立部署到生产环境

## 微服务是怎么演化来的？

传统服务打包的war、jar包很慢，项目中一个模块出现了问题，会牵连整个系统

传统服务并发量不足，会先扩充机器，再前方加上负载均衡功能，每个机器上运行的都是相同的内容

，而随着项目的升级，功能庞大，每次更改升级都需要重新打包部署十分繁杂。



## 微服务与单体架构区别？

（1）单体架构所有的模块全都耦合在一块，代码量大，维护困难。

​     微服务**每个模块就相当于一个单独的项目**，代码量明显减少，遇到问题也相对来说比较好解决。

（2）单体架构所有的模块都共用一个数据库，存储方式比较单一。

​     微服务**每个模块都可以使用不同的存储方式**（比如有的用redis，有的用mysql等），数据库也是单个模块对应自己的数据库。

（3）单体架构所有的模块开发所使用的技术一样。

​     微服务**每个模块都可以使用不同的开发技术**，开发模式更灵活。 

## 什么样的项目适合微服务？

微服务可以按照业务功能本身的独立性来划分，如果系统提供的业务是非常底层的，如：操作系统内核、存储系统、网络系统、数据库系统等等，这类系统都偏底层，功能和功能之间有着紧密的配合关系，如果强制拆分为较小的服务单元，会让集成工作量急剧上升，并且这种人为的切割无法带来业务上的真正的隔离，所以无法做到独立部署和运行，也就不适合做成微服务了。



## 什么是Restful？

网络上所有的事物都被抽象为资源

每个资源都有一个唯一的资源标识符

同一个资源具有多种表现形式（xml，json）

对资源的各种操作不会改变资源表示符

所有的操作都是无状态的

符合Rest原则的架构方式即可称为Restful

GET，获取数据

PUT，更新或者添加数据

DELETE，删除数据

POST，添加数据

# Spring Cloud

Spring Cloud是分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的结合体，本身并不是一种技术，俗称微服务全家桶，

## Spring Cloud和Spring Boot是什么关系？

Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务，Spring Cloud是一个基于Spring Boot实现的开发工具；Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架； Spring Boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud很大的一部分是基于Spring Boot来实现，必须基于Spring Boot开发。可以单独使用Spring Boot开发项目，但是Spring Cloud离不开 Spring Boot。



# 注册中心

## Eureka

1.x可以使用，2.0停止更新

![](..\imgs\Eureka.jpg)

### **Eureka Server：注册中心服务端**

注册中心服务端主要对外提供了三个功能：

**服务注册**
服务提供者启动时，会通过 Eureka Client 向 Eureka Server 注册信息，Eureka Server 会存储该服务的信息，Eureka Server 内部有二层缓存机制来维护整个注册表

**提供注册表**
服务消费者在调用服务时，如果 Eureka Client 没有缓存注册表的话，会从 Eureka Server 获取最新的注册表

**同步状态**
Eureka Client 通过注册、心跳机制和 Eureka Server 同步当前客户端的状态。

### **Eureka Client：注册中心客户端**

Eureka Client 是一个 Java 客户端，用于简化与 Eureka Server 的交互。Eureka Client 会拉取、更新和缓存 Eureka Server 中的信息。因此当所有的 Eureka Server 节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者，但是当服务有更改的时候会出现信息不一致。

**Register: 服务注册**
服务的提供者，将自身注册到注册中心，服务提供者也是一个 Eureka Client。当 Eureka Client 向 Eureka Server 注册时，它提供自身的元数据，比如 IP 地址、端口，运行状况指示符 URL，主页等。

**Renew: 服务续约**
Eureka Client 会每隔 30 秒发送一次心跳来续约。 通过续约来告知 Eureka Server 该 Eureka Client 运行正常，没有出现问题。 默认情况下，如果 Eureka Server 在 90 秒内没有收到 Eureka Client 的续约，Server 端会将实例从其注册表中删除，此时间可配置，一般情况不建议更改。

**Eviction 服务剔除**
当 Eureka Client 和 Eureka Server 不再有心跳时，Eureka Server 会将该服务实例从服务注册列表中删除，即服务剔除。

**Cancel: 服务下线**
Eureka Client 在程序关闭时向 Eureka Server 发送取消请求。 发送请求后，该客户端实例信息将从 Eureka Server 的实例注册表中删除。

**GetRegisty: 获取注册列表信息**
Eureka Client 从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与 Eureka Client 的缓存信息不同，Eureka Client 自动处理。

### 自我保护机制

为了防止EurekaClient可以正常运行，但是在与EurekaServer网络不通顺的情况下，**为了保持整个系统的高可用**，EurekaServer不会立刻将EurekaClient服务剔除

EurekaServer在一定时间内(默认90s)没有收到某个微服务实例的心跳，EurekaServer将注销该实例。但是因为网络故障（延时、卡顿、拥挤），微服务与EurekaServer无法正常通信。但是此时**微服务本身是健康的，本不应该注销**

Eureka Server 在运行期间会去统计心跳失败比例在 15 分钟之内是否低于 85%，如果低于 85%，Eureka Server 即会进入自我保护机制，**为了防止误杀服务而提供的一个机制**。

当个别客户端出现心跳失联时，则认为是客户端的问题，剔除掉客户端；当 Eureka 捕获到大量的心跳失败时，则认为可能是网络问题，进入自我保护机制；当客户端心跳恢复时，Eureka 会自动退出自我保护机制。

注意：

如果在保护期内刚好这个服务提供者非正常下线了，此时服务消费者就会拿到一个无效的服务实例，即会调用失败。对于这个问题需要服务消费者端要有一些容错机制，如重试，断路器等。

### 为什么要使用三级缓存？

读写分离，保证并发量，

### 三级缓存机制



## Zookeeper

## Consul

Consul是一套开源的分布式服务发现和配置管理系统，GO语言开发

## 异同点

| 组件名    | 语言 | CAP  | 服务健康检查 | 对外暴露接口 |      |
| --------- | ---- | ---- | ------------ | ------------ | ---- |
| Eureka    | Java | AP   |              | HTTP         |      |
| Zookeeper | Java | CP   |              | 客户端       |      |
| Consul    | Go   | CP   |              | HTTP/DNS     |      |



# 服务调用

## Ribbon

Ribbon是Netflix发布的开源项目，提供**客户端的软件负载均衡算法和服务调用**。可以实现自定义的负载均衡算法。

实质：**负载均衡+RestTemplate调用**

注：目前已进入维护

### Ribbon和Nginx区别

Ribbon本地负载均衡，在调用微服务接口时，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC

Nginx是服务器负载均衡，客户端所有请求都会交给Nginx，然后由Nginx实现转发请求

### 核心组件IRule

1. RoundRobinRule 轮询

2. RandomRule 随机（默认）

3. AvailabilityFilteringRule

   会先过滤掉多次访问故障而处于**断路器跳闸状态**和**并发的连接数量超过阀值**的服务，然后对剩余的服务列表安装轮询策略进行访问

4. WeightedResponseTimeRule

   根据**平均响应时间**计算所有的服务的权重

5. RetryRule

   先按照RoundRobinRule(轮询)的策略获取服务，如果获取的服务失败则**在指定的时间会进行重试**，进行获取可用的服务

6. BestAvailableRule

   会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个**并发量最小**的服务

7. ZoneAvoidanceRule

   复合判断Server所在区域的**性能**和Server的**可用性**，并进行选择

## OpenFeign

Feign停止更新



# 服务降级

分布式体系中每个服务有多个依赖关系，也称为“**扇出**”，在扇出的链路上某个服务有时候将不可避免出现失败，导致对服务的调用占用越来越多的系统资源，引起系统崩溃，发生“雪崩效应”



## Hystrix

Hystrix是一个用于分布式系统的延迟和容错的开源库，保证在一个依赖出问题的情况下，**不会导致整体服务失败，避免级联故障，提高分布式系统的弹性**

“断路器”本身是一种开关装置，某个服务发生故障后，通过断路器的故障监控，向调用方返回一个符合预期的、可处理的**备选响应**（FallBack），而**不是长时间的等待**或者**抛出调用方无法处理的异常**

### 服务降级

​	服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好处理FallBack

​	既可以配置在服务提供端，又可以配置到服务消费端，一般配置到服务消费端 

#### 哪些情况会发生降级

1. 程序运行异常
2. 超时
3. 服务熔断触发服务降级
4. 线程池/信号量充满

### 服务熔断

当扇出链路某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错相应信息

当检测到该节点微服务调用响应正常后，回复调用链路

![](..\imgs\circuit breaker.png)

### 服务限流

秒杀等高并发操作，进行排队，一秒钟N个，有序进行

## resilience4j



## sentinel





# 服务网关

## Zuul

Zuul 1.x基于Servlet2.5，使用阻塞I/O架构，不支持长连接（WebSocket），与Nginx设计模式很像，Nginx使用C++实现，Zuul使用Java实现

## Gateway

SpringCloud Gateway是SpringCloud的一个全新项目，基于Spring5.0+Spring Boot2.0和Project Reactor（低层Netty）等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一API路由管理方式，目标代替zuul

### 三大概念

web请求，通过一些匹配条件，定位到真正的服务节点

匹配的方式将做Predicate，实现这个匹配方式叫Filter，对外表现出来的功能就是路由

#### Route路由

由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由

#### Predicate断言

#### Filter过滤

 过滤器在请求前后执行业务逻辑

之前：

​	参数校验、权限校验、流量监控、日志输出、协议转换

之后：

​	相应内容、响应头修改、日志输出、流量监控

### 配置方式

1. yml
2. 容器注册RouteLocator



# 配置中心

微服务意味着将单体应用中的业务拆分成一个个子服务，每个服务粒度相对较小，系统中会出现大量服务，每个服务都需要必要的配置信息才能运行

需要一套**集中式的**、**动态的配置**管理设施

## SpringCloud Config

为微服务架构中的微服务提供集中化的外部配置，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置

![](..\imgs\springconfig.jpg)

## 配置动态刷新问题

运维对GitHub上配置文件内容作出调整，ConfigServer配置中心立刻响应，而在ConfigClient客户端没有任何相应，需要重新启动加载。

解决：

1. 手动版

   引入actuator监控，并暴露监控端口，@RefreshScope修改Controller，最后需要发送Post请求刷新客户端

2. 自动版需要引入消息总线



# 消息总线

在微服务架构系统中，通常会使用**轻量级的消息代理**来构建一个**共用的消息主题**，并让系统中所有微服务实例都连接上来。该**主题中产生的消息会被所有实例监听和消费**，所以称为消息总线

## SpringCloud Bus

SpringCloud Bus是用来将分布式系统的节点与轻量级消息系统连接起来的框架，它整合了Java的事件处理机制和消息中间件的功能。支持RabbitMQ和Kafka

### 基本原理

ConfigClient实例都都监听MQ中同一个topic（默认是SpringCloudBus）。当一个服务刷新数据的时候，把信息放到Topic中，这样其他监听同一个Topic的服务就能得到通知，然后去更新自身的配置



# 消息驱动

MQ消息中间件，有很多种

- ActiveMQ
- RabbitMQ
- RocketMQ
- Kafka

需要一种技术，让我们不在关注具体MQ的细节，只需要用一种适配绑定的方式，自动在各种MQ内切换

## SpringCloud Stream

SpringCloud Stream构建消息驱动微服务的框架。

屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型。

应用程序通过inputs或者outputs来与SpringCloud Stream中binder对象交互，通过我们配置来进行binding（绑定），而SpringCloud Stream的binder对象负责与消息中间件交互

### 重复消费问题（分组）

微服务应用放置于同一个group中，同一个组内会发生竞争关系，就能保证消息只会被其中一个应用消费一次

### 持久化



# 链路跟踪



## SpringCloud Sleuth