## Linux开机启动过程

![](..\imgs\Linux启动过程.png)

**BIOS**

BIOS(Basic Input/Output System)，基本输入输出系统，该系统存储于主板的ROM芯片上，首先会检测CPU和内存等硬件设备，然后加载BIOS程序到内存中，BIOS程序中存储了磁盘的启动顺序，BIOS会按照启动顺序去查找第一个磁盘头的MBR信息

**MBR**

MBR(Master Boot Record)，主引导记录，MBR存储于磁盘的头部，大小为512bytes，其中，446bytes用于存储BootLoader程序，64bytes用于存储分区表信息，最后2bytes用于MBR的有效性检查。

**GRUB**

多系统启动程序(Grand Unified Bootloader)，识别文件系统，查找Kernel文件信息，加载Kerner程序

**Kernel**

Kernel，内核，Kernel是Linux系统最主要的程序，以压缩的文件形式存储在硬盘中。通过initrd(Initial RAM Disk)这个文件，装载驱动模块，挂载到真正的rootfs，将initrd从内存中删除。然后开始装载第一个用户空间的进程，执行/sbin/init，将控制权交给init程序

**Init**

进行OS初始化操作，实际上是根据/etc/inittab(定义了系统默认运行级别)设定的动作进行脚本的执行，一个被执行的脚本为/etc/rc.d/rc.sysinit



## linux的0号进程和1号进程

Linux下有3个特殊的进程，idle进程(PID = 0), init进程(PID = 1)和kthreadd(PID = 2)

-  idle进程由系统自动创建, 运行在内核态

  也是唯一一个没有通过fork或者kernel_thread产生的进程。完成加载系统后，演变为进程调度、交换

-  init进程由idle通过kernel_thread创建，在内核空间完成初始化后, 加载init程序, 并最终用户空间

  在系统启动完成完成后，init将变为守护进程监视系统其他进程。

-  kthreadd进程由idle通过kernel_thread创建，并始终运行在内核空间, 负责所有内核线程的调度和管理 

  

## Linux 为什么多进程能够读写正在删除的文件？

linux是通过link的数量来控制文件删除，只有当一个文件不存在任何link的时候，这个文件才会被删除。

而每个文件都会有2个link计数器-- i_count 和 i_nlink

i_count是内存引用计数器，i_nlink是硬盘引用计数器。再换句话说，当文件被某个进程引用时，i_count 就会增加；当创建文件的硬连接的时候，i_nlink 就会增加。

而删除文件rm 操作只是将 i_nlink 置为 0 了；由于文件被进程引用的缘故，i_count 不为 0，所以系统没有真正删除这个文件



## 程序如何调用内核的系统调用？

内核与用户程序是拥有不同级别的，内核在Ring0，应用程序在Ring3，其他的驱动程序位于Ring1、Ring2（但真正使用只有两层，R0和R3）。

大多数指令可以同时使用于R0层和R3层，但有些和系统设置相关的指令却只能在R0层被使用，或者在R3层的使用受到限制，用户不能直接调用里面的系统调用

实际上，用户程序通过编译器，设置了80软中断，实现了态的切换，由内核在内核态下完成调用

## 通信处理

TCP/IP的众多应用协议大多以客户端/服务端的形式运行，服务器端需要提前启动，准备接受客户端的请求。

这些服务端程序在UNIX系统当中叫做守护进程。如HTTP的服务端程序是httpd，ssh的服务端程序是sshd。

UNIX中并不需要这些守护进程逐个启动，而是启动一个可以代表它们接收客户端请求的**inetd**（互联网守护进程）服务程序即可，它是一种**超级守护进程**，收到客户端请求以后会**fork**新的进程，并转换exec为sshd等各个守护进程

## 如何从用户态切换到内核态？

1. 系统调用

   用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，其核心是使用软件中断

2. 异常

   当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，比如缺页异常

3. 外围设备的中断

   当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等

## 进程的状态

**新建：**进程正在被创建

**就绪状态：TASK_RUNNING**，当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，这种状态称为就绪状态

**执行状态：TASK_RUNNING**，进程已获得CPU，其程序正在执行

**阻塞状态：**正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃CPU而处于暂停状态，亦即进程的执行受到阻塞，把这种暂停状态称为阻塞状态，有时也称为等待状态或封锁状态。比如进程当中调用wait()函数，会使得进程进入到阻塞状态

**终止：TASK_ZOMBIE，**进程完成执行

## 进程间通信方式

进程通信(Interprocess Communication，IPC)是一个进程与另一个进程间共享消息的一种通信方式，IPC机制是消息从一个进程的地址空间拷贝到另一个进程的地址空间

### PIPE，管道，无名管道

每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走。缓冲区是一个循环队列实现的

1. 它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。
2. 它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）

### FIFO，命名管道

1. FIFO可以在无关的进程之间交换数据，与无名管道不同。
2. FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中

### 信号（Signal）

是一种处理异步事件的方式，用于通知接受进程有某种事件发生，除了用于进程外，还可以发送信号给进程本身。

如kill命令发送的信号 

### 信号量

信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。

### 消息队列

消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。**它独立于发送和接收进程而存在**

用于消息，不是简单的数据信息传递，消息队列还包括消息有优先级、消息到达通知等丰富内容。

### 共享内存

共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区

1. 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
2. 不存在单向限制
3. 因为多个进程可以同时操作，所以需要进行同步。
4. 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

### Socket

面向网络的进程间通信方式，用于不同机器间的进程通信

## 进程调度的时机

- 中断处理过程，直接调用schedule()
- 内核线程，可以直接调用schedule()进行进程切换，可以主动调用也可以被动调用
- 用户态进程无法实现主动调用，只能在中断处理过程中调用

## 进程的切换

进程的上下文切换是与中断保存现场是不同的

- 中断前后是在同一个进程上下文中，只是用户态转向内核态来执行

- 进程上下文包含了进制需要执行的所有信息
  - 用户地址空间：程序代码，数据，用户栈
  - 控制信息：进程描述符，内核堆栈
  - 硬件上下文

## 一个进程最大能使用多少空间？

32位处理器上的每个进程都可以使用4GB的内存，2^32次，Linux将3GB给进程使用，1GB给内核，Windows将2GB给进程，2GB给内核

64位处理器需要根据主板地址总线，一般是2^48次

## 什么是硬链接和软链接？

 Linux 下的文件是通过索引节点(inode)来识别文件

1. 硬连接（Hard Link）

   硬链接可以认为是一个指针，指向文件索引节点，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1 。硬链接文件与原始文件其实是同一个文件，只是名字不同

   - 不可以跨分区

   ```shell
   ln fileName newFileName
   ```

2. 软连接（Symbolic Link）

   也称为符号连接，这个文件包含了另一个文件的路径名。

   软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接.

   - 可以跨分区

   ```shell
   ln -s fileName newFileName
   ```

   注意：删除软连接后面不能加/，会删除掉软连接那个目录的文件

## wait和waitpid()

wait函数

父进程一旦调用了wait就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止

waitpid函数

可以指定对应的进程的pid，可以指定option，若由pid指定的子进程未发生状态改变(没有结束)，则waitpid()不阻塞，立即返回0

## 孤儿进程与僵尸进程

​	在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程到底什么时候结束。 当一个进程完成它的工作终止之后，**子进程结束给父进程发送SIGCHLD信号**，它的父进程需要调用**wait()**或者**waitpid()**系统调用取得子进程的终止状态

**孤儿进程：**

​	一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作

**僵尸进程：**

​	一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，虽然系统会回收大部分资源，比如打开的文件，占用的内存等，但是子进程的进程描述符仍然保存在系统中。



如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。



僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源

杀死父进程是不会产生僵尸进程的

## fork()，如何判断哪个是父哪个是子进程

fork()函数返回值，父进程fork()后返回子进程的pid号，子进程fork()后返回值为0

## kill -9 能杀孤儿进程吗？能杀僵尸进程吗？

kill -9 pid是向进程号为pid的进程发送SIGKILL信号，事实上，SIGKILL信号是直接发给init进程的，它收到该信号后，负责终止pid指定的进程。可以杀孤儿进程

kill不能将僵尸状态的进程杀死，因为处于僵尸状态的进程已经是死了，它只留下Zombie的数据结构



## Linux的inode的理解

文件储存在硬盘上，硬盘的最小存储单位叫做"扇区"（Sector）。每个扇区储存512字节

操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个"块"（block）。这种由多个扇区组成的"块"，是文件存取的最小单位。"块"的大小，最常见的是4KB，即连续八个 sector组成一个 block。

文件数据都储存在"块"中，那么很显然，我们还必须找到一个地方储存文件的元信息（关于信息的信息），比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为"索引节点"。

inode包含文件的元信息，具体来说有以下内容：

* 文件的字节数
* 文件拥有者的User ID
* 文件的Group ID
* 文件的读、写、执行权限
* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。
* 链接数，即有多少文件名指向这个inode
* 文件数据block的位置

## 红黑树的应用

使用特点

- key-value 存储
- 顺序，定时任务

结构体，rb_node

1. **进程调度**

   task_struck中，每个进程都有一个虚拟运行时间，进程运行一段时间后其虚拟运行时间会增加，优先级高的进程的虚拟时间增加的慢。所有非实时可运行进程都以虚拟运行时间为key值挂在一棵红黑树上，在CFS调度中总是选择虚拟运行时间小的进程进行调度运行

2. **内存管理**

   在task_struck中，每个进程都有一个mm_struct的成员用于管理该进程的虚拟内存空间，其中维护了rb_root，即红黑树的根，该进程的所有虚拟空间块（虚拟地址不连续）都以起始虚拟地址为key值挂在该红黑树上。

3. **网络IO时**

   sk_buff

4. **epoll**

   epoll内核中维护了一个内核事件表，它是将所有的文件描述符全部都存放在内核中，系统去检测有事件发生的时候触发回调。添加一个文件描述符进行监听或者删除一个文件描述符时使用的是epoll_ctl函数
   
   ps: 为什么不用hashtable？因为当时kernel里有现成的rbtree而没有通用的hashtable

## 进程控制块PCB

Linux的进程控制块为一个由结构**task_struct**所定义的数据结构，其中包括管理进程所需的各种信息

```
tty：控制台
fs：文件系统
files：文件描述符
mm：内存管理
signal：信号描述
```

## 创建一个新进程在内核中的执行过程

fork、vfork和clone三个系统调用都可以创建一个新进程，而且都是通过调用do_fork来实现进程的创建

子进程大部分和父进程是一样的，但是还是有一些不一样的，如PID，内核堆栈，链表关系

1. 复制PCB，即复制task_struct

   ```C
   err = arch_dup_task_struct(tsk, orig);
   ```

2. 要给新进程分配一个新的内核堆栈

   ```C
   ti = alloc_thread_info_node(tsk, node);
   tsk->stack = ti;
   setup_thread_stack(tsk, orig); //这里只是复制thread_info，而非复制内核堆栈
   ```

3. 修改复制好的数据，pid、进程链表

## 一个新创建的子进程，它是从哪一行代码开始执行的？

执行的起点是设定好的，也就是通过eip寄存器指定代码行



## COW 写时复制

写时复制（Copy On Write），在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程

在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个，==当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间==



## 控制台输入ls会发生什么？为什么敲击键盘就会在终端上显示？

1. Shell程序分析输入参数，确定ls命令（内建命令不创建子Shel，l而外部命令创建子Shell）
2. 调用系统调用fork生成一个shell本身的拷贝（软中断，用户态转到内核态）
3. 调用exec系统调用将ls的可执行文件装入内存
4. 从系统调用返回
5. shell和ls都得以执行

&符号表示该命令在后台执行，而当命令执行过程中，我们是无法仅需输入命令的，这是因为父进程在fork执行shell命令的同时，回执行wait等待子进程结束，除非用户主动Ctrl+C中止命令执行或者Ctrl+z置入后台执行